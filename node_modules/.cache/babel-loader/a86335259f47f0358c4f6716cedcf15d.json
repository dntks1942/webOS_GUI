{"ast":null,"code":"\"use strict\";\n\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\nexports.stopImmediate = exports.stop = exports.returnsTrue = exports.preventDefault = exports.oneOf = exports.not = exports.log = exports.handle = exports.forProp = exports.forKeyCode = exports.forKey = exports.forEventProp = exports.forwardWithPrevent = exports.forwardCustom = exports.forward = exports.callOnEvent = exports.call = exports.adaptEvent = exports[\"default\"] = void 0;\n\nvar _cond = _interopRequireDefault(require(\"ramda/src/cond\"));\n\nvar _curry = _interopRequireDefault(require(\"ramda/src/curry\"));\n\nvar _keymap = require(\"../keymap\");\n\nfunction _interopRequireDefault(obj) {\n  return obj && obj.__esModule ? obj : {\n    \"default\": obj\n  };\n}\n/**\n * `core/handle` provides a set of utilities to support handling events for `kind()`s and\n * `React.Component`s. The default export, `handle()`, generates an event handler function from a\n * set of input functions. The input functions either process or filter the event. If an input\n * function returns `true`, `handle()` will continue processing the event by calling the next input\n * function in the chain. If it returns `false` (or any falsy value like `null` or `undefined`),\n * the event handling chain stops at that input function.\n *\n * Example:\n * ```\n * import {forKey, forward, handle, preventDefault} from '@enact/core/handle';\n *\n * // logEnter will contain a function that accepts an event, a props object, and a context object\n * const logEnter = handle(\n *   forward('onKeyDown'),  // forwards the event to the function passed in the onKeyDown prop\n *   forKey('enter'),       // if the event.keyCode maps to the enter key, allows event processing to continue\n *   preventDefault,        // calls event.preventDefault() to prevent the `keypress` event\n *   (ev, props) => {       // custom event handler -- in this case, logging some text\n *     // since it doesn't return `true`, no further input functions would be called after this one\n *     console.log('The Enter key was pressed down');\n *   }\n * ).finally(() => {\n * \t console.log('This will log at the end no matter what happens within the handler above')\n * });\n * ```\n *\n * `handle()` can also be bound to a component instance which allows it to access the instance\n * `props` and `context`. This allows you to write consistent event handlers for components created\n * either with `kind()` or ES6 classes without worrying about from where the props are sourced.\n *\n * Handlers can either be bound directly using the native `bind()` method or using the `bindAs()`\n * utility method that is appended to the handler.\n *\n * Example:\n * ```\n * import {forKey, forward, handle, preventDefault} from '@enact/core/handle';\n * import React from 'react';\n *\n * class MyComponent extends React.Component {\n *   // bind handle() to the instance\n *   constructor () {\n *     super();\n *\n *     // logEnter will be bound to `this` and set as this.handleKeyDown\n *     //\n *     // Equivalent to the following with the advantage of set the function name to be displayed in\n *     // development tool call stacks\n *     //\n *     //   this.handleKeyDown = logEnter.bind(this)\n *     logEnter.bindAs(this, 'handleKeyDown');\n *   }\n *\n *   render () {\n *     return (\n *       <div onKeyDown={this.handleKeyDown} />\n *     );\n *   }\n * }\n * ```\n *\n * @module core/handle\n * @exports adaptEvent\n * @exports call\n * @exports callOnEvent\n * @exports forward\n * @exports forwardWithPrevent\n * @exports forEventProp\n * @exports forKey\n * @exports forKeyCode\n * @exports forProp\n * @exports handle\n * @exports log\n * @exports oneOf\n * @exports preventDefault\n * @exports returnsTrue\n * @exports stop\n * @exports stopImmediate\n */\n\n/**\n * The signature for event handlers\n *\n * @callback EventHandler\n * @memberof core/handle\n * @param {any} event\n */\n\n/**\n * The signature for event handling functions supported by `handle` and related functions\n *\n * @callback HandlerFunction\n * @memberof core/handle\n * @param {any} event\n * @param {Object<string, any>} props\n * @param {Object<string, any>} context\n */\n\n/**\n * The signature for {@link core/handle.adaptEvent} parameter `adapter`\n *\n * @callback EventAdapter\n * @memberof core/handle\n * @param {any} event\n * @param {Object<string, any>} props\n * @param {Object<string, any>} context\n * @returns {any}\n */\n// Accepts an array of handlers, sanitizes them, and returns a handler function\n// compose(allPass, map(makeSafeHandler));\n\n\nvar makeHandler = function makeHandler(handlers) {\n  // allowing shadowing here to provide a meaningful function name in dev tools\n  // eslint-disable-next-line no-shadow\n  return function handle() {\n    for (var _len = arguments.length, args = new Array(_len), _key = 0; _key < _len; _key++) {\n      args[_key] = arguments[_key];\n    }\n\n    for (var i = 0; i < handlers.length; i++) {\n      var fn = handlers[i];\n\n      if (typeof fn !== 'function' || fn.apply(this, args)) {\n        continue;\n      }\n\n      return false;\n    }\n\n    return true;\n  };\n}; // Loose check to determine if obj is component-ish if it has both props and context members\n\n\nvar hasPropsAndContext = function hasPropsAndContext(obj) {\n  return obj && Object.prototype.hasOwnProperty.call(obj, 'props') && Object.prototype.hasOwnProperty.call(obj, 'context');\n};\n\nvar named = function named(fn, name) {\n  if (process.env.NODE_ENV !== \"production\") {\n    try {\n      Object.defineProperty(fn, 'name', {\n        value: name,\n        writeable: false,\n        enumerable: false\n      });\n    } catch (err) {// unable to set name of function\n    }\n  }\n\n  return fn;\n};\n\nvar bindAs = function bindAs(fn, obj, name) {\n  var namedFunction = name ? named(fn, name) : fn;\n  var bound = namedFunction.bind(obj);\n\n  if (name) {\n    obj[name] = bound;\n  }\n\n  return bound;\n};\n\nvar decorateHandleFunction = function decorateHandleFunction(fn) {\n  fn.named = function (name) {\n    return named(fn, name);\n  };\n\n  fn.bindAs = function (obj, name) {\n    return bindAs(fn, obj, name);\n  };\n\n  return fn;\n};\n/**\n * Allows generating event handlers by chaining input functions to filter or short-circuit the\n * handling flow. Any input function that returns a falsy value will stop the chain.\n *\n * The returned handler function has a `finally()` member that accepts a function and returns a new\n * handler function. The accepted function is called once the original handler completes regardless\n * of the returned value.\n *\n * @method   handle\n * @param    {...HandlerFunction}  handlers List of handlers to process the event.\n *\n * @returns  {EventHandler}\tA function that accepts an event which is dispatched to each of the\n *                          provided handlers.\n * @memberof core/handle\n * @public\n */\n\n\nvar handle = function handle() {\n  for (var _len2 = arguments.length, handlers = new Array(_len2), _key2 = 0; _key2 < _len2; _key2++) {\n    handlers[_key2] = arguments[_key2];\n  }\n\n  var h = makeHandler(handlers); // In order to support binding either handle (handle.bind(this)) or a handler\n  // (a = handle(), a.bind(this)), we cache `this` here and use it as the fallback for props and\n  // context if fn() doesn't have its own `this`.\n\n  var _outer = this;\n\n  var fn = function prepareHandleArgs(ev, props, context) {\n    var caller = null; // if handle() was bound to a class, use its props and context. otherwise, we accept\n    // incoming props/context as would be provided by computed/handlers from kind()\n\n    if (hasPropsAndContext(this)) {\n      caller = this;\n      props = this.props;\n      context = this.context;\n    } else if (hasPropsAndContext(_outer)) {\n      caller = _outer;\n      props = _outer.props;\n      context = _outer.context;\n    }\n\n    return h.call(caller, ev, props, context);\n  };\n\n  fn[\"finally\"] = function (cleanup) {\n    return decorateHandleFunction(function handleWithFinally(ev, props, context) {\n      var result = false;\n\n      if (hasPropsAndContext(this)) {\n        props = this.props;\n        context = this.context;\n      }\n\n      try {\n        result = fn.call(this, ev, props, context);\n      } finally {\n        cleanup.call(this, ev, props, context);\n      }\n\n      return result;\n    });\n  };\n\n  return decorateHandleFunction(fn);\n};\n/**\n * Calls the first handler whose condition passes. Each branch must be passed as an array with the\n * first element being the condition function and the second being the handler function. The same\n * arguments are passed to both the condition function and the handler function. The value returned\n * from the handler is returned.\n *\n * Example:\n * ```\n * const handler = oneOf(\n * \t[forKey('enter'), handleEnter],\n * \t[forKey('left'), handleLeft],\n * \t[forKey('right'), handleRight]\n * );\n * ```\n *\n * @method   oneOf\n * @param    {...[HandlerFunction, HandlerFunction]}  handlers List of conditions and handlers to process the event\n *\n * @returns  {HandlerFunction} A function that accepts an event which is dispatched to each of the\n *                             conditions and, if it passes, onto the provided handler.\n * @memberof core/handle\n * @public\n */\n\n\nexports.handle = handle;\n\nvar oneOf = handle.oneOf = function () {\n  for (var _len3 = arguments.length, handlers = new Array(_len3), _key3 = 0; _key3 < _len3; _key3++) {\n    handlers[_key3] = arguments[_key3];\n  }\n\n  return handle.call(this, (0, _cond[\"default\"])(handlers));\n};\n/**\n * A function that always returns `true`. Optionally accepts a `handler` function which is called\n * before returning `true`.\n *\n * Example:\n * ```\n * // Used to coerce an existing function into a handler\n * const coercedHandler = handle(\n *   returnsTrue(doesSomething),\n *   willAlwaysBeCalled\n * );\n *\n * // Used to emulate if/else blocks with `oneOf`\n * const ifElseHandler = oneOf(\n * \t[forKey('enter'), handleEnter],\n * \t[returnsTrue, handleOtherwise]\n * );\n * ```\n *\n * @method   returnsTrue\n * @param    {Function}  [handler]  Handler function called before returning `true`.\n *\n * @returns  {HandlerFunction}\t   A function that returns `true`\n * @memberof core/handle\n * @public\n */\n\n\nexports.oneOf = oneOf;\n\nvar returnsTrue = handle.returnsTrue = function (handler) {\n  if (handler && typeof handler === 'function') {\n    return named(function () {\n      for (var _len4 = arguments.length, args = new Array(_len4), _key4 = 0; _key4 < _len4; _key4++) {\n        args[_key4] = arguments[_key4];\n      }\n\n      handler.apply(this, args);\n      return true;\n    }, 'returnsTrue');\n  }\n\n  return true;\n};\n/**\n * Calls a named function on the event and returns `true`.\n *\n * Example:\n * ```\n * import {callOnEvent, handle} from '@enact/core/handle';\n *\n * const callsCustomMethod = handle(\n *\tcallOnEvent('customMethod'),\n *\t(ev) => console.log('ev.customMethod() was called', ev)\n * );\n * ```\n *\n * @method   callOnEvent\n * @param    {String}     methodName  Name of the method to call on the event\n * @param    {Object}     ev          Event payload\n *\n * @returns  {true}                   Always returns `true`\n * @curried\n * @memberof core/handle\n * @private\n */\n\n\nexports.returnsTrue = returnsTrue;\nvar callOnEvent = handle.callOnEvent = (0, _curry[\"default\"])(function (methodName, ev) {\n  if (ev[methodName]) {\n    ev[methodName]();\n  } else if (ev.nativeEvent && ev.nativeEvent[methodName]) {\n    // In some cases (notably stopImmediatePropagation), React doesn't include a desired method\n    // on its proxy so we check the native event as well.\n    ev.nativeEvent[methodName]();\n  }\n\n  return true;\n});\n/**\n * Allows handling to continue if the value of `prop` on the event strictly equals `value`\n *\n * Example:\n * ```\n * import {forEventProp, handle} from '@enact/core/handle';\n *\n * const logWhenXEqualsZero = handle(\n *   forEventProp('x', 0),\n *   (ev) => console.log('ev.x was equal to zero', ev)\n * );\n * ```\n *\n * @method   forEventProp\n * @param    {String}\t   prop   Name of property on event\n * @param    {*}           value  Value of property\n * @param    {Object}      ev     Event payload\n *\n * @returns  {Boolean}            Returns `true` if `prop` on `event` strictly equals `value`\n * @curried\n * @memberof core/handle\n * @public\n */\n\nexports.callOnEvent = callOnEvent;\nvar forEventProp = handle.forEventProp = (0, _curry[\"default\"])(function (prop, value, ev) {\n  return ev[prop] === value;\n});\n/**\n * Forwards the event to a function at `name` on `props`. If the specified prop is `undefined` or\n * is not a function, it is ignored. The return value of the forwarded function is ignored and\n * `true` is always returned instead.\n *\n * Example:\n * ```\n * import {forward, handle} from '@enact/core/handle';\n *\n * const forwardAndLog = handle(\n *   forward('onClick'),\n *   (ev) => console.log('event forwarded to onClick from props', ev)\n * );\n * ```\n *\n * @method   forward\n * @param    {String}    name   Name of method on the `props`\n * @param    {Object}    ev     Event payload\n * @param    {Object}    props  Props object\n *\n * @returns  {true}             Always returns `true`\n * @curried\n * @memberof core/handle\n * @public\n */\n\nexports.forEventProp = forEventProp;\nvar forward = handle.forward = (0, _curry[\"default\"])(named(function (name, ev, props) {\n  var fn = props && props[name];\n\n  if (typeof fn === 'function') {\n    fn(ev);\n  }\n\n  return true;\n}, 'forward'));\n/**\n * Calls `event.preventDefault()` and returns `true`.\n *\n * Example:\n * ```\n * import {handle, preventDefault} from '@enact/core/handle';\n *\n * const preventAndLog = handle(\n *   preventDefault,\n *   (ev) => console.log('preventDefault called', ev)\n * );\n * ```\n *\n * @method   preventDefault\n * @param    {Object}        ev  Event payload\n *\n * @returns  {true}              Always returns `true`\n * @memberof core/handle\n * @public\n */\n\nexports.forward = forward;\n\nvar _preventDefault = handle.preventDefault = callOnEvent('preventDefault');\n/**\n * Forwards the event to a function at `name` on `props` with capability to prevent default\n * behavior. If the specified prop is `undefined` or is not a function, it is ignored. Returns\n * `false` when `event.preventDefault()` has been called in a handler.\n *\n * Example:\n * ```\n * import {forwardWithPrevent, handle} from '@enact/core/handle';\n *\n * const forwardPreventDefault = handle(\n *   forwardWithPrevent('onClick'),\n *   (ev) => console.log('default action', ev)\n * );\n * ```\n *\n * @method   forwardWithPrevent\n * @param    {String}    name   Name of method on the `props`\n * @param    {Object}    ev     Event payload\n * @param    {Object}    props  Props object\n *\n * @returns  {Boolean}          Returns `true` if default action is prevented\n * @curried\n * @memberof core/handle\n * @private\n */\n\n\nexports.preventDefault = _preventDefault;\nvar forwardWithPrevent = handle.forwardWithPrevent = (0, _curry[\"default\"])(named(function (name, ev, props) {\n  var prevented = false;\n  var wrappedEvent = Object.assign({}, ev, {\n    preventDefault: function preventDefault() {\n      prevented = true;\n\n      _preventDefault(ev);\n    }\n  });\n  forward(name, wrappedEvent, props);\n  return !prevented;\n}, 'forwardWithPrevent'));\n/**\n * Calls `event.stopPropagation()` and returns `true`\n *\n * Example:\n * ```\n * import {handle, stop} from '@enact/core/handle';\n *\n * const stopAndLog = handle(\n *   stop,\n *   (ev) => console.log('stopPropagation called', ev)\n * );\n * ```\n *\n * @method   stop\n * @param    {Object}   ev  Event payload\n *\n * @returns  {true}         Always returns `true`\n * @curried\n * @memberof core/handle\n * @public\n */\n\nexports.forwardWithPrevent = forwardWithPrevent;\nvar stop = handle.stop = named(callOnEvent('stopPropagation'), 'stop');\n/**\n * Calls `event.stopImmediatePropagation()` and returns `true`\n *\n * Example:\n * ```\n * import {handle, stopImmediate} from '@enact/core/handle';\n *\n * const stopImmediateAndLog = handle(\n *   stopImmediate,\n *   (ev) => console.log('stopImmediatePropagation called', ev)\n * );\n * ```\n *\n * @method   stopImmediate\n * @param    {Object}       ev  Event payload\n *\n * @returns  {true}             Always returns `true`\n * @curried\n * @memberof core/handle\n * @public\n */\n\nexports.stop = stop;\nvar stopImmediate = handle.stopImmediate = callOnEvent('stopImmediatePropagation');\n/**\n * Allows event handling to continue if `event.keyCode === value`.\n *\n * Example:\n * ```\n * import {forKeyCode, handle} from '@enact/core/handle';\n *\n * const logForEscapeKey = handle(\n *   forKeyCode(27),\n *   (ev) => console.log('Escape key pressed down', ev)\n * );\n * ```\n *\n * @method   forKeyCode\n * @param    {Number}    value  `keyCode` to test\n * @param    {Object}    ev     Event payload\n *\n * @returns  {Boolean}          Returns `true` if `event.keyCode` strictly equals `value`\n * @curried\n * @memberof core/handle\n * @public\n */\n\nexports.stopImmediate = stopImmediate;\nvar forKeyCode = handle.forKeyCode = forEventProp('keyCode');\n/**\n * Allows handling to continue if the event's keyCode is mapped to `name` within\n * {@link core/keymap}.\n *\n * Example:\n * ```\n * import {forKey, handle} from '@enact/core/handle';\n *\n * const logForEnterKey = handle(\n *   forKey('enter'),\n *   (ev) => console.log('Enter key pressed down', ev)\n * );\n * ```\n *\n * @see      {@link core/keymap}\n * @method   forKey\n * @param    {String}    name   Name from {@link core/keymap}\n * @param    {Object}    ev     Event payload\n *\n * @returns  {Boolean}          Returns `true` if `event.keyCode` is mapped to `name`\n * @curried\n * @memberof core/handle\n * @public\n */\n\nexports.forKeyCode = forKeyCode;\nvar forKey = handle.forKey = (0, _curry[\"default\"])(function (name, ev) {\n  return (0, _keymap.is)(name, ev.keyCode);\n});\n/**\n * Allows handling to continue if the value of `prop` on the props strictly equals `value`.\n *\n * Example:\n * ```\n * import {forProp, handle} from '@enact/core/handle';\n *\n * const logWhenChecked = handle(\n *   forProp('checked', true),\n *   (ev) => console.log('checked prop is true', ev)\n * );\n * ```\n *\n * @method   forProp\n * @param    {String}    prop   Name of property on props object\n * @param    {*}         value  Value of property\n * @param    {Object}    ev     Event payload\n * @param    {Object}    props  Props object\n *\n * @returns  {Boolean}          Returns `true` if the value of `props[prop]` strictly equals `value`\n * @curried\n * @memberof core/handle\n * @public\n */\n\nexports.forKey = forKey;\nvar forProp = handle.forProp = (0, _curry[\"default\"])(function (prop, value, ev, props) {\n  return props[prop] === value;\n});\n/**\n * Logs the event, props, and context optionally preceded by a custom message. Will only log in\n * development mode.\n *\n * Example:\n * ```\n * import {forProp, handle, log} from '@enact/core/handle';\n *\n * const logWhenChecked = handle(\n *   forProp('checked', true),\n *   log('checked props is true')\n * );\n * ```\n *\n * @method   log\n * @param    {String}     message  Custom message\n * @param    {Object}     ev       Event payload\n * @param    {...*}       [args]   Any args passed are logged\n *\n * @returns  {true}                Always returns `true`\n * @curried\n * @memberof core/handle\n * @public\n */\n\nexports.forProp = forProp;\nvar log = handle.log = (0, _curry[\"default\"])(function (message, ev) {\n  if (process.env.NODE_ENV !== \"production\") {\n    var _console;\n\n    for (var _len5 = arguments.length, args = new Array(_len5 > 2 ? _len5 - 2 : 0), _key5 = 2; _key5 < _len5; _key5++) {\n      args[_key5 - 2] = arguments[_key5];\n    } // eslint-disable-next-line no-console\n\n\n    (_console = console).log.apply(_console, [message, ev].concat(args));\n  }\n\n  return true;\n});\n/**\n * Invokes a method by name on the component to which {@link core/handle.handle} is bound.\n *\n * If the methods exists on the object, it is called with the event, props, and context and its\n * return value is returned.\n *\n * If the method does not exist or handle isn't bound to an instance, it returns `false`.\n *\n * Example:\n * ```\n * import {call, handle, forProp} from '@enact/core/handle';\n *\n * const incrementIfEnabled = handle(\n *   forProp('disabled', false),\n *   call('increment')\n * );\n *\n * class Counter extends React.Component {\n *   constructor () {\n *     super();\n *\n *     this.handleIncrement = incrementIfEnabled.bind(this);\n *   }\n *\n *   render () {\n *     // ...\n *   }\n * }\n * ```\n *\n * @method   call\n * @param    {String}     method  Name of method\n *\n * @returns  {HandlerFunction}    Returns the value returned by `method`, or `false` if the method\n *                                does not exist\n * @memberof core/handle\n * @public\n */\n\nexports.log = log;\n\nvar call = function call(method) {\n  return named(function () {\n    if (this && this[method]) {\n      return this[method].apply(this, arguments);\n    }\n\n    return false;\n  }, 'call');\n};\n/**\n * Adapts an event with `adapter` before calling `handler`.\n *\n * The `adapter` function receives the same arguments as any handler. The value returned from\n * `adapter` is passed as the first argument to `handler` with the remaining arguments kept the\n * same. This is often useful to generate a custom event payload before forwarding on to a callback.\n *\n * Example:\n * ```\n * import {adaptEvent, forward} from '@enact/core/handle';\n *\n * // calls the onChange callback with an event payload containing a type and value member\n * const incrementAndChange = adaptEvent(\n * \t(ev, props) => ({\n * \t  type: 'onChange',\n * \t  value: props.value + 1\n * \t}),\n * \tforward('onChange')\n * )\n * ```\n *\n * @method   adaptEvent\n * @param    {EventAdapter}     adapter  Function to adapt the event payload\n * @param    {HandlerFunction}  handler  Handler to call with the handler function\n *\n * @returns  {HandlerFunction}           Returns an [event handler]{@link core/handle.HandlerFunction} (suitable for passing to handle) that returns the result of `handler`\n * @curried\n * @memberof core/handle\n * @public\n */\n\n\nexports.call = call;\nvar adaptEvent = handle.adaptEvent = (0, _curry[\"default\"])(function (adapter, handler) {\n  return named(function (ev) {\n    for (var _len6 = arguments.length, args = new Array(_len6 > 1 ? _len6 - 1 : 0), _key6 = 1; _key6 < _len6; _key6++) {\n      args[_key6 - 1] = arguments[_key6];\n    }\n\n    return handler.call.apply(handler, [this, adapter.call.apply(adapter, [this, ev].concat(args))].concat(args));\n  }, 'adaptEvent');\n});\n/**\n * Creates a handler that will forward the event to a function at `name` on `props`.\n *\n * If `adapter` is not specified, a new event payload will be generated with a `type` member with\n * the `name` of the custom event. If `adapter` is specified, the `type` member is added to the\n * value returned by `adapter`.\n *\n * The `adapter` function receives the same arguments as any handler. The value returned from\n * `adapter` is passed as the first argument to `handler` with the remaining arguments kept the\n * same. This is often useful to generate a custom event payload before forwarding on to a callback.\n *\n * Example:\n * ```\n * import {forwardCustom} from '@enact/core/handle';\n *\n * // calls the onChange callback with the event: {type: 'onChange'}\n * const forwardChange = forwardCustom('onChange');\n *\n * // calls the onChange callback with the event: {type: 'onChange', index}\n * const forwardChangeWithIndex = forwardCustom('onChange', (ev, {index}) => ({index}));\n * ```\n *\n * @method   forwardCustom\n * @param    {String}        name      Name of method on the `props`\n * @param    {EventAdapter}  [adapter] Function to adapt the event payload\n *\n * @returns  {HandlerFunction}         Returns an [event handler]{@link core/handle.EventHandler}\n *                                     (suitable for passing to handle or used directly within\n *                                     `handlers` in [kind]{@link core/kind}) that will forward the\n *                                     custom event.\n * @memberof core/handle\n * @public\n */\n\nexports.adaptEvent = adaptEvent;\n\nvar forwardCustom = handle.forwardCustom = function (name, adapter) {\n  return handle(adaptEvent(function () {\n    var ev = adapter ? adapter.apply(void 0, arguments) : null; // Handle either no adapter or a non-object return from the adapter\n\n    if (!ev || typeof ev !== 'object') {\n      ev = {};\n    }\n\n    ev.type = name;\n    return ev;\n  }, forward(name))).named('forwardCustom');\n};\n/**\n * Accepts a handler and returns the logical complement of the value returned from the handler.\n *\n * Example:\n * ```\n * import {forProp, forward, not, handle} from '@enact/core/handle';\n *\n * // calls the onChange callback when disabled is not true\n * const handleChange = handle(\n *  not(forProp('disabled', true)),\n *  forward('onChange')\n * )\n * ```\n *\n * @method   not\n * @param    {HandlerFunction}  handler  Handler to complement\n *\n * @returns  {HandlerFunction}           Returns an [event\n *                                       handler]{@link core/handle.HandlerFunction} (suitable for\n *                                       passing to handle) that returns the complement of the\n *                                       return value of `handler`\n * @curried\n * @memberof core/handle\n * @public\n */\n\n\nexports.forwardCustom = forwardCustom;\n\nvar not = handle.not = function (handler) {\n  return function () {\n    return !handler.apply(void 0, arguments);\n  };\n};\n\nexports.not = not;\nvar _default = handle;\nexports[\"default\"] = _default;","map":{"version":3,"sources":["/Users/sonjaeseong/workspace/webOS/CARROT/webOS_GUI/node_modules/@enact/core/handle/handle.js"],"names":["Object","defineProperty","exports","value","stopImmediate","stop","returnsTrue","preventDefault","oneOf","not","log","handle","forProp","forKeyCode","forKey","forEventProp","forwardWithPrevent","forwardCustom","forward","callOnEvent","call","adaptEvent","_cond","_interopRequireDefault","require","_curry","_keymap","obj","__esModule","makeHandler","handlers","_len","arguments","length","args","Array","_key","i","fn","apply","hasPropsAndContext","prototype","hasOwnProperty","named","name","process","env","NODE_ENV","writeable","enumerable","err","bindAs","namedFunction","bound","bind","decorateHandleFunction","_len2","_key2","h","_outer","prepareHandleArgs","ev","props","context","caller","cleanup","handleWithFinally","result","_len3","_key3","handler","_len4","_key4","methodName","nativeEvent","prop","_preventDefault","prevented","wrappedEvent","assign","is","keyCode","message","_console","_len5","_key5","console","concat","method","adapter","_len6","_key6","type","_default"],"mappings":"AAAA;;AAEAA,MAAM,CAACC,cAAP,CAAsBC,OAAtB,EAA+B,YAA/B,EAA6C;AAC3CC,EAAAA,KAAK,EAAE;AADoC,CAA7C;AAGAD,OAAO,CAACE,aAAR,GAAwBF,OAAO,CAACG,IAAR,GAAeH,OAAO,CAACI,WAAR,GAAsBJ,OAAO,CAACK,cAAR,GAAyBL,OAAO,CAACM,KAAR,GAAgBN,OAAO,CAACO,GAAR,GAAcP,OAAO,CAACQ,GAAR,GAAcR,OAAO,CAACS,MAAR,GAAiBT,OAAO,CAACU,OAAR,GAAkBV,OAAO,CAACW,UAAR,GAAqBX,OAAO,CAACY,MAAR,GAAiBZ,OAAO,CAACa,YAAR,GAAuBb,OAAO,CAACc,kBAAR,GAA6Bd,OAAO,CAACe,aAAR,GAAwBf,OAAO,CAACgB,OAAR,GAAkBhB,OAAO,CAACiB,WAAR,GAAsBjB,OAAO,CAACkB,IAAR,GAAelB,OAAO,CAACmB,UAAR,GAAqBnB,OAAO,CAAC,SAAD,CAAP,GAAqB,KAAK,CAA7X;;AAEA,IAAIoB,KAAK,GAAGC,sBAAsB,CAACC,OAAO,CAAC,gBAAD,CAAR,CAAlC;;AAEA,IAAIC,MAAM,GAAGF,sBAAsB,CAACC,OAAO,CAAC,iBAAD,CAAR,CAAnC;;AAEA,IAAIE,OAAO,GAAGF,OAAO,CAAC,WAAD,CAArB;;AAEA,SAASD,sBAAT,CAAgCI,GAAhC,EAAqC;AAAE,SAAOA,GAAG,IAAIA,GAAG,CAACC,UAAX,GAAwBD,GAAxB,GAA8B;AAAE,eAAWA;AAAb,GAArC;AAA0D;AAEjG;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;;AACA,IAAIE,WAAW,GAAG,SAASA,WAAT,CAAqBC,QAArB,EAA+B;AAC/C;AACA;AACA,SAAO,SAASnB,MAAT,GAAkB;AACvB,SAAK,IAAIoB,IAAI,GAAGC,SAAS,CAACC,MAArB,EAA6BC,IAAI,GAAG,IAAIC,KAAJ,CAAUJ,IAAV,CAApC,EAAqDK,IAAI,GAAG,CAAjE,EAAoEA,IAAI,GAAGL,IAA3E,EAAiFK,IAAI,EAArF,EAAyF;AACvFF,MAAAA,IAAI,CAACE,IAAD,CAAJ,GAAaJ,SAAS,CAACI,IAAD,CAAtB;AACD;;AAED,SAAK,IAAIC,CAAC,GAAG,CAAb,EAAgBA,CAAC,GAAGP,QAAQ,CAACG,MAA7B,EAAqCI,CAAC,EAAtC,EAA0C;AACxC,UAAIC,EAAE,GAAGR,QAAQ,CAACO,CAAD,CAAjB;;AAEA,UAAI,OAAOC,EAAP,KAAc,UAAd,IAA4BA,EAAE,CAACC,KAAH,CAAS,IAAT,EAAeL,IAAf,CAAhC,EAAsD;AACpD;AACD;;AAED,aAAO,KAAP;AACD;;AAED,WAAO,IAAP;AACD,GAhBD;AAiBD,CApBD,C,CAoBG;;;AAGH,IAAIM,kBAAkB,GAAG,SAASA,kBAAT,CAA4Bb,GAA5B,EAAiC;AACxD,SAAOA,GAAG,IAAI3B,MAAM,CAACyC,SAAP,CAAiBC,cAAjB,CAAgCtB,IAAhC,CAAqCO,GAArC,EAA0C,OAA1C,CAAP,IAA6D3B,MAAM,CAACyC,SAAP,CAAiBC,cAAjB,CAAgCtB,IAAhC,CAAqCO,GAArC,EAA0C,SAA1C,CAApE;AACD,CAFD;;AAIA,IAAIgB,KAAK,GAAG,SAASA,KAAT,CAAeL,EAAf,EAAmBM,IAAnB,EAAyB;AACnC,MAAIC,OAAO,CAACC,GAAR,CAAYC,QAAZ,KAAyB,YAA7B,EAA2C;AACzC,QAAI;AACF/C,MAAAA,MAAM,CAACC,cAAP,CAAsBqC,EAAtB,EAA0B,MAA1B,EAAkC;AAChCnC,QAAAA,KAAK,EAAEyC,IADyB;AAEhCI,QAAAA,SAAS,EAAE,KAFqB;AAGhCC,QAAAA,UAAU,EAAE;AAHoB,OAAlC;AAKD,KAND,CAME,OAAOC,GAAP,EAAY,CAAC;AACd;AACF;;AAED,SAAOZ,EAAP;AACD,CAbD;;AAeA,IAAIa,MAAM,GAAG,SAASA,MAAT,CAAgBb,EAAhB,EAAoBX,GAApB,EAAyBiB,IAAzB,EAA+B;AAC1C,MAAIQ,aAAa,GAAGR,IAAI,GAAGD,KAAK,CAACL,EAAD,EAAKM,IAAL,CAAR,GAAqBN,EAA7C;AACA,MAAIe,KAAK,GAAGD,aAAa,CAACE,IAAd,CAAmB3B,GAAnB,CAAZ;;AAEA,MAAIiB,IAAJ,EAAU;AACRjB,IAAAA,GAAG,CAACiB,IAAD,CAAH,GAAYS,KAAZ;AACD;;AAED,SAAOA,KAAP;AACD,CATD;;AAWA,IAAIE,sBAAsB,GAAG,SAASA,sBAAT,CAAgCjB,EAAhC,EAAoC;AAC/DA,EAAAA,EAAE,CAACK,KAAH,GAAW,UAAUC,IAAV,EAAgB;AACzB,WAAOD,KAAK,CAACL,EAAD,EAAKM,IAAL,CAAZ;AACD,GAFD;;AAIAN,EAAAA,EAAE,CAACa,MAAH,GAAY,UAAUxB,GAAV,EAAeiB,IAAf,EAAqB;AAC/B,WAAOO,MAAM,CAACb,EAAD,EAAKX,GAAL,EAAUiB,IAAV,CAAb;AACD,GAFD;;AAIA,SAAON,EAAP;AACD,CAVD;AAWA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;;AAGA,IAAI3B,MAAM,GAAG,SAASA,MAAT,GAAkB;AAC7B,OAAK,IAAI6C,KAAK,GAAGxB,SAAS,CAACC,MAAtB,EAA8BH,QAAQ,GAAG,IAAIK,KAAJ,CAAUqB,KAAV,CAAzC,EAA2DC,KAAK,GAAG,CAAxE,EAA2EA,KAAK,GAAGD,KAAnF,EAA0FC,KAAK,EAA/F,EAAmG;AACjG3B,IAAAA,QAAQ,CAAC2B,KAAD,CAAR,GAAkBzB,SAAS,CAACyB,KAAD,CAA3B;AACD;;AAED,MAAIC,CAAC,GAAG7B,WAAW,CAACC,QAAD,CAAnB,CAL6B,CAKE;AAC/B;AACA;;AAEA,MAAI6B,MAAM,GAAG,IAAb;;AAEA,MAAIrB,EAAE,GAAG,SAASsB,iBAAT,CAA2BC,EAA3B,EAA+BC,KAA/B,EAAsCC,OAAtC,EAA+C;AACtD,QAAIC,MAAM,GAAG,IAAb,CADsD,CACnC;AACnB;;AAEA,QAAIxB,kBAAkB,CAAC,IAAD,CAAtB,EAA8B;AAC5BwB,MAAAA,MAAM,GAAG,IAAT;AACAF,MAAAA,KAAK,GAAG,KAAKA,KAAb;AACAC,MAAAA,OAAO,GAAG,KAAKA,OAAf;AACD,KAJD,MAIO,IAAIvB,kBAAkB,CAACmB,MAAD,CAAtB,EAAgC;AACrCK,MAAAA,MAAM,GAAGL,MAAT;AACAG,MAAAA,KAAK,GAAGH,MAAM,CAACG,KAAf;AACAC,MAAAA,OAAO,GAAGJ,MAAM,CAACI,OAAjB;AACD;;AAED,WAAOL,CAAC,CAACtC,IAAF,CAAO4C,MAAP,EAAeH,EAAf,EAAmBC,KAAnB,EAA0BC,OAA1B,CAAP;AACD,GAfD;;AAiBAzB,EAAAA,EAAE,CAAC,SAAD,CAAF,GAAgB,UAAU2B,OAAV,EAAmB;AACjC,WAAOV,sBAAsB,CAAC,SAASW,iBAAT,CAA2BL,EAA3B,EAA+BC,KAA/B,EAAsCC,OAAtC,EAA+C;AAC3E,UAAII,MAAM,GAAG,KAAb;;AAEA,UAAI3B,kBAAkB,CAAC,IAAD,CAAtB,EAA8B;AAC5BsB,QAAAA,KAAK,GAAG,KAAKA,KAAb;AACAC,QAAAA,OAAO,GAAG,KAAKA,OAAf;AACD;;AAED,UAAI;AACFI,QAAAA,MAAM,GAAG7B,EAAE,CAAClB,IAAH,CAAQ,IAAR,EAAcyC,EAAd,EAAkBC,KAAlB,EAAyBC,OAAzB,CAAT;AACD,OAFD,SAEU;AACRE,QAAAA,OAAO,CAAC7C,IAAR,CAAa,IAAb,EAAmByC,EAAnB,EAAuBC,KAAvB,EAA8BC,OAA9B;AACD;;AAED,aAAOI,MAAP;AACD,KAf4B,CAA7B;AAgBD,GAjBD;;AAmBA,SAAOZ,sBAAsB,CAACjB,EAAD,CAA7B;AACD,CAhDD;AAiDA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;;AAGApC,OAAO,CAACS,MAAR,GAAiBA,MAAjB;;AAEA,IAAIH,KAAK,GAAGG,MAAM,CAACH,KAAP,GAAe,YAAY;AACrC,OAAK,IAAI4D,KAAK,GAAGpC,SAAS,CAACC,MAAtB,EAA8BH,QAAQ,GAAG,IAAIK,KAAJ,CAAUiC,KAAV,CAAzC,EAA2DC,KAAK,GAAG,CAAxE,EAA2EA,KAAK,GAAGD,KAAnF,EAA0FC,KAAK,EAA/F,EAAmG;AACjGvC,IAAAA,QAAQ,CAACuC,KAAD,CAAR,GAAkBrC,SAAS,CAACqC,KAAD,CAA3B;AACD;;AAED,SAAO1D,MAAM,CAACS,IAAP,CAAY,IAAZ,EAAkB,CAAC,GAAGE,KAAK,CAAC,SAAD,CAAT,EAAsBQ,QAAtB,CAAlB,CAAP;AACD,CAND;AAOA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;;AAGA5B,OAAO,CAACM,KAAR,GAAgBA,KAAhB;;AAEA,IAAIF,WAAW,GAAGK,MAAM,CAACL,WAAP,GAAqB,UAAUgE,OAAV,EAAmB;AACxD,MAAIA,OAAO,IAAI,OAAOA,OAAP,KAAmB,UAAlC,EAA8C;AAC5C,WAAO3B,KAAK,CAAC,YAAY;AACvB,WAAK,IAAI4B,KAAK,GAAGvC,SAAS,CAACC,MAAtB,EAA8BC,IAAI,GAAG,IAAIC,KAAJ,CAAUoC,KAAV,CAArC,EAAuDC,KAAK,GAAG,CAApE,EAAuEA,KAAK,GAAGD,KAA/E,EAAsFC,KAAK,EAA3F,EAA+F;AAC7FtC,QAAAA,IAAI,CAACsC,KAAD,CAAJ,GAAcxC,SAAS,CAACwC,KAAD,CAAvB;AACD;;AAEDF,MAAAA,OAAO,CAAC/B,KAAR,CAAc,IAAd,EAAoBL,IAApB;AACA,aAAO,IAAP;AACD,KAPW,EAOT,aAPS,CAAZ;AAQD;;AAED,SAAO,IAAP;AACD,CAbD;AAcA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;;AAGAhC,OAAO,CAACI,WAAR,GAAsBA,WAAtB;AACA,IAAIa,WAAW,GAAGR,MAAM,CAACQ,WAAP,GAAqB,CAAC,GAAGM,MAAM,CAAC,SAAD,CAAV,EAAuB,UAAUgD,UAAV,EAAsBZ,EAAtB,EAA0B;AACtF,MAAIA,EAAE,CAACY,UAAD,CAAN,EAAoB;AAClBZ,IAAAA,EAAE,CAACY,UAAD,CAAF;AACD,GAFD,MAEO,IAAIZ,EAAE,CAACa,WAAH,IAAkBb,EAAE,CAACa,WAAH,CAAeD,UAAf,CAAtB,EAAkD;AACvD;AACA;AACAZ,IAAAA,EAAE,CAACa,WAAH,CAAeD,UAAf;AACD;;AAED,SAAO,IAAP;AACD,CAVsC,CAAvC;AAWA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEAvE,OAAO,CAACiB,WAAR,GAAsBA,WAAtB;AACA,IAAIJ,YAAY,GAAGJ,MAAM,CAACI,YAAP,GAAsB,CAAC,GAAGU,MAAM,CAAC,SAAD,CAAV,EAAuB,UAAUkD,IAAV,EAAgBxE,KAAhB,EAAuB0D,EAAvB,EAA2B;AACzF,SAAOA,EAAE,CAACc,IAAD,CAAF,KAAaxE,KAApB;AACD,CAFwC,CAAzC;AAGA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEAD,OAAO,CAACa,YAAR,GAAuBA,YAAvB;AACA,IAAIG,OAAO,GAAGP,MAAM,CAACO,OAAP,GAAiB,CAAC,GAAGO,MAAM,CAAC,SAAD,CAAV,EAAuBkB,KAAK,CAAC,UAAUC,IAAV,EAAgBiB,EAAhB,EAAoBC,KAApB,EAA2B;AACrF,MAAIxB,EAAE,GAAGwB,KAAK,IAAIA,KAAK,CAAClB,IAAD,CAAvB;;AAEA,MAAI,OAAON,EAAP,KAAc,UAAlB,EAA8B;AAC5BA,IAAAA,EAAE,CAACuB,EAAD,CAAF;AACD;;AAED,SAAO,IAAP;AACD,CAR0D,EAQxD,SARwD,CAA5B,CAA/B;AASA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA3D,OAAO,CAACgB,OAAR,GAAkBA,OAAlB;;AAEA,IAAI0D,eAAe,GAAGjE,MAAM,CAACJ,cAAP,GAAwBY,WAAW,CAAC,gBAAD,CAAzD;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;;AAGAjB,OAAO,CAACK,cAAR,GAAyBqE,eAAzB;AACA,IAAI5D,kBAAkB,GAAGL,MAAM,CAACK,kBAAP,GAA4B,CAAC,GAAGS,MAAM,CAAC,SAAD,CAAV,EAAuBkB,KAAK,CAAC,UAAUC,IAAV,EAAgBiB,EAAhB,EAAoBC,KAApB,EAA2B;AAC3G,MAAIe,SAAS,GAAG,KAAhB;AACA,MAAIC,YAAY,GAAG9E,MAAM,CAAC+E,MAAP,CAAc,EAAd,EAAkBlB,EAAlB,EAAsB;AACvCtD,IAAAA,cAAc,EAAE,SAASA,cAAT,GAA0B;AACxCsE,MAAAA,SAAS,GAAG,IAAZ;;AAEAD,MAAAA,eAAe,CAACf,EAAD,CAAf;AACD;AALsC,GAAtB,CAAnB;AAOA3C,EAAAA,OAAO,CAAC0B,IAAD,EAAOkC,YAAP,EAAqBhB,KAArB,CAAP;AACA,SAAO,CAACe,SAAR;AACD,CAXgF,EAW9E,oBAX8E,CAA5B,CAArD;AAYA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA3E,OAAO,CAACc,kBAAR,GAA6BA,kBAA7B;AACA,IAAIX,IAAI,GAAGM,MAAM,CAACN,IAAP,GAAcsC,KAAK,CAACxB,WAAW,CAAC,iBAAD,CAAZ,EAAiC,MAAjC,CAA9B;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEAjB,OAAO,CAACG,IAAR,GAAeA,IAAf;AACA,IAAID,aAAa,GAAGO,MAAM,CAACP,aAAP,GAAuBe,WAAW,CAAC,0BAAD,CAAtD;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEAjB,OAAO,CAACE,aAAR,GAAwBA,aAAxB;AACA,IAAIS,UAAU,GAAGF,MAAM,CAACE,UAAP,GAAoBE,YAAY,CAAC,SAAD,CAAjD;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEAb,OAAO,CAACW,UAAR,GAAqBA,UAArB;AACA,IAAIC,MAAM,GAAGH,MAAM,CAACG,MAAP,GAAgB,CAAC,GAAGW,MAAM,CAAC,SAAD,CAAV,EAAuB,UAAUmB,IAAV,EAAgBiB,EAAhB,EAAoB;AACtE,SAAO,CAAC,GAAGnC,OAAO,CAACsD,EAAZ,EAAgBpC,IAAhB,EAAsBiB,EAAE,CAACoB,OAAzB,CAAP;AACD,CAF4B,CAA7B;AAGA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA/E,OAAO,CAACY,MAAR,GAAiBA,MAAjB;AACA,IAAIF,OAAO,GAAGD,MAAM,CAACC,OAAP,GAAiB,CAAC,GAAGa,MAAM,CAAC,SAAD,CAAV,EAAuB,UAAUkD,IAAV,EAAgBxE,KAAhB,EAAuB0D,EAAvB,EAA2BC,KAA3B,EAAkC;AACtF,SAAOA,KAAK,CAACa,IAAD,CAAL,KAAgBxE,KAAvB;AACD,CAF8B,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","sourcesContent":["\"use strict\";\n\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\nexports.stopImmediate = exports.stop = exports.returnsTrue = exports.preventDefault = exports.oneOf = exports.not = exports.log = exports.handle = exports.forProp = exports.forKeyCode = exports.forKey = exports.forEventProp = exports.forwardWithPrevent = exports.forwardCustom = exports.forward = exports.callOnEvent = exports.call = exports.adaptEvent = exports[\"default\"] = void 0;\n\nvar _cond = _interopRequireDefault(require(\"ramda/src/cond\"));\n\nvar _curry = _interopRequireDefault(require(\"ramda/src/curry\"));\n\nvar _keymap = require(\"../keymap\");\n\nfunction _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { \"default\": obj }; }\n\n/**\n * `core/handle` provides a set of utilities to support handling events for `kind()`s and\n * `React.Component`s. The default export, `handle()`, generates an event handler function from a\n * set of input functions. The input functions either process or filter the event. If an input\n * function returns `true`, `handle()` will continue processing the event by calling the next input\n * function in the chain. If it returns `false` (or any falsy value like `null` or `undefined`),\n * the event handling chain stops at that input function.\n *\n * Example:\n * ```\n * import {forKey, forward, handle, preventDefault} from '@enact/core/handle';\n *\n * // logEnter will contain a function that accepts an event, a props object, and a context object\n * const logEnter = handle(\n *   forward('onKeyDown'),  // forwards the event to the function passed in the onKeyDown prop\n *   forKey('enter'),       // if the event.keyCode maps to the enter key, allows event processing to continue\n *   preventDefault,        // calls event.preventDefault() to prevent the `keypress` event\n *   (ev, props) => {       // custom event handler -- in this case, logging some text\n *     // since it doesn't return `true`, no further input functions would be called after this one\n *     console.log('The Enter key was pressed down');\n *   }\n * ).finally(() => {\n * \t console.log('This will log at the end no matter what happens within the handler above')\n * });\n * ```\n *\n * `handle()` can also be bound to a component instance which allows it to access the instance\n * `props` and `context`. This allows you to write consistent event handlers for components created\n * either with `kind()` or ES6 classes without worrying about from where the props are sourced.\n *\n * Handlers can either be bound directly using the native `bind()` method or using the `bindAs()`\n * utility method that is appended to the handler.\n *\n * Example:\n * ```\n * import {forKey, forward, handle, preventDefault} from '@enact/core/handle';\n * import React from 'react';\n *\n * class MyComponent extends React.Component {\n *   // bind handle() to the instance\n *   constructor () {\n *     super();\n *\n *     // logEnter will be bound to `this` and set as this.handleKeyDown\n *     //\n *     // Equivalent to the following with the advantage of set the function name to be displayed in\n *     // development tool call stacks\n *     //\n *     //   this.handleKeyDown = logEnter.bind(this)\n *     logEnter.bindAs(this, 'handleKeyDown');\n *   }\n *\n *   render () {\n *     return (\n *       <div onKeyDown={this.handleKeyDown} />\n *     );\n *   }\n * }\n * ```\n *\n * @module core/handle\n * @exports adaptEvent\n * @exports call\n * @exports callOnEvent\n * @exports forward\n * @exports forwardWithPrevent\n * @exports forEventProp\n * @exports forKey\n * @exports forKeyCode\n * @exports forProp\n * @exports handle\n * @exports log\n * @exports oneOf\n * @exports preventDefault\n * @exports returnsTrue\n * @exports stop\n * @exports stopImmediate\n */\n\n/**\n * The signature for event handlers\n *\n * @callback EventHandler\n * @memberof core/handle\n * @param {any} event\n */\n\n/**\n * The signature for event handling functions supported by `handle` and related functions\n *\n * @callback HandlerFunction\n * @memberof core/handle\n * @param {any} event\n * @param {Object<string, any>} props\n * @param {Object<string, any>} context\n */\n\n/**\n * The signature for {@link core/handle.adaptEvent} parameter `adapter`\n *\n * @callback EventAdapter\n * @memberof core/handle\n * @param {any} event\n * @param {Object<string, any>} props\n * @param {Object<string, any>} context\n * @returns {any}\n */\n// Accepts an array of handlers, sanitizes them, and returns a handler function\n// compose(allPass, map(makeSafeHandler));\nvar makeHandler = function makeHandler(handlers) {\n  // allowing shadowing here to provide a meaningful function name in dev tools\n  // eslint-disable-next-line no-shadow\n  return function handle() {\n    for (var _len = arguments.length, args = new Array(_len), _key = 0; _key < _len; _key++) {\n      args[_key] = arguments[_key];\n    }\n\n    for (var i = 0; i < handlers.length; i++) {\n      var fn = handlers[i];\n\n      if (typeof fn !== 'function' || fn.apply(this, args)) {\n        continue;\n      }\n\n      return false;\n    }\n\n    return true;\n  };\n}; // Loose check to determine if obj is component-ish if it has both props and context members\n\n\nvar hasPropsAndContext = function hasPropsAndContext(obj) {\n  return obj && Object.prototype.hasOwnProperty.call(obj, 'props') && Object.prototype.hasOwnProperty.call(obj, 'context');\n};\n\nvar named = function named(fn, name) {\n  if (process.env.NODE_ENV !== \"production\") {\n    try {\n      Object.defineProperty(fn, 'name', {\n        value: name,\n        writeable: false,\n        enumerable: false\n      });\n    } catch (err) {// unable to set name of function\n    }\n  }\n\n  return fn;\n};\n\nvar bindAs = function bindAs(fn, obj, name) {\n  var namedFunction = name ? named(fn, name) : fn;\n  var bound = namedFunction.bind(obj);\n\n  if (name) {\n    obj[name] = bound;\n  }\n\n  return bound;\n};\n\nvar decorateHandleFunction = function decorateHandleFunction(fn) {\n  fn.named = function (name) {\n    return named(fn, name);\n  };\n\n  fn.bindAs = function (obj, name) {\n    return bindAs(fn, obj, name);\n  };\n\n  return fn;\n};\n/**\n * Allows generating event handlers by chaining input functions to filter or short-circuit the\n * handling flow. Any input function that returns a falsy value will stop the chain.\n *\n * The returned handler function has a `finally()` member that accepts a function and returns a new\n * handler function. The accepted function is called once the original handler completes regardless\n * of the returned value.\n *\n * @method   handle\n * @param    {...HandlerFunction}  handlers List of handlers to process the event.\n *\n * @returns  {EventHandler}\tA function that accepts an event which is dispatched to each of the\n *                          provided handlers.\n * @memberof core/handle\n * @public\n */\n\n\nvar handle = function handle() {\n  for (var _len2 = arguments.length, handlers = new Array(_len2), _key2 = 0; _key2 < _len2; _key2++) {\n    handlers[_key2] = arguments[_key2];\n  }\n\n  var h = makeHandler(handlers); // In order to support binding either handle (handle.bind(this)) or a handler\n  // (a = handle(), a.bind(this)), we cache `this` here and use it as the fallback for props and\n  // context if fn() doesn't have its own `this`.\n\n  var _outer = this;\n\n  var fn = function prepareHandleArgs(ev, props, context) {\n    var caller = null; // if handle() was bound to a class, use its props and context. otherwise, we accept\n    // incoming props/context as would be provided by computed/handlers from kind()\n\n    if (hasPropsAndContext(this)) {\n      caller = this;\n      props = this.props;\n      context = this.context;\n    } else if (hasPropsAndContext(_outer)) {\n      caller = _outer;\n      props = _outer.props;\n      context = _outer.context;\n    }\n\n    return h.call(caller, ev, props, context);\n  };\n\n  fn[\"finally\"] = function (cleanup) {\n    return decorateHandleFunction(function handleWithFinally(ev, props, context) {\n      var result = false;\n\n      if (hasPropsAndContext(this)) {\n        props = this.props;\n        context = this.context;\n      }\n\n      try {\n        result = fn.call(this, ev, props, context);\n      } finally {\n        cleanup.call(this, ev, props, context);\n      }\n\n      return result;\n    });\n  };\n\n  return decorateHandleFunction(fn);\n};\n/**\n * Calls the first handler whose condition passes. Each branch must be passed as an array with the\n * first element being the condition function and the second being the handler function. The same\n * arguments are passed to both the condition function and the handler function. The value returned\n * from the handler is returned.\n *\n * Example:\n * ```\n * const handler = oneOf(\n * \t[forKey('enter'), handleEnter],\n * \t[forKey('left'), handleLeft],\n * \t[forKey('right'), handleRight]\n * );\n * ```\n *\n * @method   oneOf\n * @param    {...[HandlerFunction, HandlerFunction]}  handlers List of conditions and handlers to process the event\n *\n * @returns  {HandlerFunction} A function that accepts an event which is dispatched to each of the\n *                             conditions and, if it passes, onto the provided handler.\n * @memberof core/handle\n * @public\n */\n\n\nexports.handle = handle;\n\nvar oneOf = handle.oneOf = function () {\n  for (var _len3 = arguments.length, handlers = new Array(_len3), _key3 = 0; _key3 < _len3; _key3++) {\n    handlers[_key3] = arguments[_key3];\n  }\n\n  return handle.call(this, (0, _cond[\"default\"])(handlers));\n};\n/**\n * A function that always returns `true`. Optionally accepts a `handler` function which is called\n * before returning `true`.\n *\n * Example:\n * ```\n * // Used to coerce an existing function into a handler\n * const coercedHandler = handle(\n *   returnsTrue(doesSomething),\n *   willAlwaysBeCalled\n * );\n *\n * // Used to emulate if/else blocks with `oneOf`\n * const ifElseHandler = oneOf(\n * \t[forKey('enter'), handleEnter],\n * \t[returnsTrue, handleOtherwise]\n * );\n * ```\n *\n * @method   returnsTrue\n * @param    {Function}  [handler]  Handler function called before returning `true`.\n *\n * @returns  {HandlerFunction}\t   A function that returns `true`\n * @memberof core/handle\n * @public\n */\n\n\nexports.oneOf = oneOf;\n\nvar returnsTrue = handle.returnsTrue = function (handler) {\n  if (handler && typeof handler === 'function') {\n    return named(function () {\n      for (var _len4 = arguments.length, args = new Array(_len4), _key4 = 0; _key4 < _len4; _key4++) {\n        args[_key4] = arguments[_key4];\n      }\n\n      handler.apply(this, args);\n      return true;\n    }, 'returnsTrue');\n  }\n\n  return true;\n};\n/**\n * Calls a named function on the event and returns `true`.\n *\n * Example:\n * ```\n * import {callOnEvent, handle} from '@enact/core/handle';\n *\n * const callsCustomMethod = handle(\n *\tcallOnEvent('customMethod'),\n *\t(ev) => console.log('ev.customMethod() was called', ev)\n * );\n * ```\n *\n * @method   callOnEvent\n * @param    {String}     methodName  Name of the method to call on the event\n * @param    {Object}     ev          Event payload\n *\n * @returns  {true}                   Always returns `true`\n * @curried\n * @memberof core/handle\n * @private\n */\n\n\nexports.returnsTrue = returnsTrue;\nvar callOnEvent = handle.callOnEvent = (0, _curry[\"default\"])(function (methodName, ev) {\n  if (ev[methodName]) {\n    ev[methodName]();\n  } else if (ev.nativeEvent && ev.nativeEvent[methodName]) {\n    // In some cases (notably stopImmediatePropagation), React doesn't include a desired method\n    // on its proxy so we check the native event as well.\n    ev.nativeEvent[methodName]();\n  }\n\n  return true;\n});\n/**\n * Allows handling to continue if the value of `prop` on the event strictly equals `value`\n *\n * Example:\n * ```\n * import {forEventProp, handle} from '@enact/core/handle';\n *\n * const logWhenXEqualsZero = handle(\n *   forEventProp('x', 0),\n *   (ev) => console.log('ev.x was equal to zero', ev)\n * );\n * ```\n *\n * @method   forEventProp\n * @param    {String}\t   prop   Name of property on event\n * @param    {*}           value  Value of property\n * @param    {Object}      ev     Event payload\n *\n * @returns  {Boolean}            Returns `true` if `prop` on `event` strictly equals `value`\n * @curried\n * @memberof core/handle\n * @public\n */\n\nexports.callOnEvent = callOnEvent;\nvar forEventProp = handle.forEventProp = (0, _curry[\"default\"])(function (prop, value, ev) {\n  return ev[prop] === value;\n});\n/**\n * Forwards the event to a function at `name` on `props`. If the specified prop is `undefined` or\n * is not a function, it is ignored. The return value of the forwarded function is ignored and\n * `true` is always returned instead.\n *\n * Example:\n * ```\n * import {forward, handle} from '@enact/core/handle';\n *\n * const forwardAndLog = handle(\n *   forward('onClick'),\n *   (ev) => console.log('event forwarded to onClick from props', ev)\n * );\n * ```\n *\n * @method   forward\n * @param    {String}    name   Name of method on the `props`\n * @param    {Object}    ev     Event payload\n * @param    {Object}    props  Props object\n *\n * @returns  {true}             Always returns `true`\n * @curried\n * @memberof core/handle\n * @public\n */\n\nexports.forEventProp = forEventProp;\nvar forward = handle.forward = (0, _curry[\"default\"])(named(function (name, ev, props) {\n  var fn = props && props[name];\n\n  if (typeof fn === 'function') {\n    fn(ev);\n  }\n\n  return true;\n}, 'forward'));\n/**\n * Calls `event.preventDefault()` and returns `true`.\n *\n * Example:\n * ```\n * import {handle, preventDefault} from '@enact/core/handle';\n *\n * const preventAndLog = handle(\n *   preventDefault,\n *   (ev) => console.log('preventDefault called', ev)\n * );\n * ```\n *\n * @method   preventDefault\n * @param    {Object}        ev  Event payload\n *\n * @returns  {true}              Always returns `true`\n * @memberof core/handle\n * @public\n */\n\nexports.forward = forward;\n\nvar _preventDefault = handle.preventDefault = callOnEvent('preventDefault');\n/**\n * Forwards the event to a function at `name` on `props` with capability to prevent default\n * behavior. If the specified prop is `undefined` or is not a function, it is ignored. Returns\n * `false` when `event.preventDefault()` has been called in a handler.\n *\n * Example:\n * ```\n * import {forwardWithPrevent, handle} from '@enact/core/handle';\n *\n * const forwardPreventDefault = handle(\n *   forwardWithPrevent('onClick'),\n *   (ev) => console.log('default action', ev)\n * );\n * ```\n *\n * @method   forwardWithPrevent\n * @param    {String}    name   Name of method on the `props`\n * @param    {Object}    ev     Event payload\n * @param    {Object}    props  Props object\n *\n * @returns  {Boolean}          Returns `true` if default action is prevented\n * @curried\n * @memberof core/handle\n * @private\n */\n\n\nexports.preventDefault = _preventDefault;\nvar forwardWithPrevent = handle.forwardWithPrevent = (0, _curry[\"default\"])(named(function (name, ev, props) {\n  var prevented = false;\n  var wrappedEvent = Object.assign({}, ev, {\n    preventDefault: function preventDefault() {\n      prevented = true;\n\n      _preventDefault(ev);\n    }\n  });\n  forward(name, wrappedEvent, props);\n  return !prevented;\n}, 'forwardWithPrevent'));\n/**\n * Calls `event.stopPropagation()` and returns `true`\n *\n * Example:\n * ```\n * import {handle, stop} from '@enact/core/handle';\n *\n * const stopAndLog = handle(\n *   stop,\n *   (ev) => console.log('stopPropagation called', ev)\n * );\n * ```\n *\n * @method   stop\n * @param    {Object}   ev  Event payload\n *\n * @returns  {true}         Always returns `true`\n * @curried\n * @memberof core/handle\n * @public\n */\n\nexports.forwardWithPrevent = forwardWithPrevent;\nvar stop = handle.stop = named(callOnEvent('stopPropagation'), 'stop');\n/**\n * Calls `event.stopImmediatePropagation()` and returns `true`\n *\n * Example:\n * ```\n * import {handle, stopImmediate} from '@enact/core/handle';\n *\n * const stopImmediateAndLog = handle(\n *   stopImmediate,\n *   (ev) => console.log('stopImmediatePropagation called', ev)\n * );\n * ```\n *\n * @method   stopImmediate\n * @param    {Object}       ev  Event payload\n *\n * @returns  {true}             Always returns `true`\n * @curried\n * @memberof core/handle\n * @public\n */\n\nexports.stop = stop;\nvar stopImmediate = handle.stopImmediate = callOnEvent('stopImmediatePropagation');\n/**\n * Allows event handling to continue if `event.keyCode === value`.\n *\n * Example:\n * ```\n * import {forKeyCode, handle} from '@enact/core/handle';\n *\n * const logForEscapeKey = handle(\n *   forKeyCode(27),\n *   (ev) => console.log('Escape key pressed down', ev)\n * );\n * ```\n *\n * @method   forKeyCode\n * @param    {Number}    value  `keyCode` to test\n * @param    {Object}    ev     Event payload\n *\n * @returns  {Boolean}          Returns `true` if `event.keyCode` strictly equals `value`\n * @curried\n * @memberof core/handle\n * @public\n */\n\nexports.stopImmediate = stopImmediate;\nvar forKeyCode = handle.forKeyCode = forEventProp('keyCode');\n/**\n * Allows handling to continue if the event's keyCode is mapped to `name` within\n * {@link core/keymap}.\n *\n * Example:\n * ```\n * import {forKey, handle} from '@enact/core/handle';\n *\n * const logForEnterKey = handle(\n *   forKey('enter'),\n *   (ev) => console.log('Enter key pressed down', ev)\n * );\n * ```\n *\n * @see      {@link core/keymap}\n * @method   forKey\n * @param    {String}    name   Name from {@link core/keymap}\n * @param    {Object}    ev     Event payload\n *\n * @returns  {Boolean}          Returns `true` if `event.keyCode` is mapped to `name`\n * @curried\n * @memberof core/handle\n * @public\n */\n\nexports.forKeyCode = forKeyCode;\nvar forKey = handle.forKey = (0, _curry[\"default\"])(function (name, ev) {\n  return (0, _keymap.is)(name, ev.keyCode);\n});\n/**\n * Allows handling to continue if the value of `prop` on the props strictly equals `value`.\n *\n * Example:\n * ```\n * import {forProp, handle} from '@enact/core/handle';\n *\n * const logWhenChecked = handle(\n *   forProp('checked', true),\n *   (ev) => console.log('checked prop is true', ev)\n * );\n * ```\n *\n * @method   forProp\n * @param    {String}    prop   Name of property on props object\n * @param    {*}         value  Value of property\n * @param    {Object}    ev     Event payload\n * @param    {Object}    props  Props object\n *\n * @returns  {Boolean}          Returns `true` if the value of `props[prop]` strictly equals `value`\n * @curried\n * @memberof core/handle\n * @public\n */\n\nexports.forKey = forKey;\nvar forProp = handle.forProp = (0, _curry[\"default\"])(function (prop, value, ev, props) {\n  return props[prop] === value;\n});\n/**\n * Logs the event, props, and context optionally preceded by a custom message. Will only log in\n * development mode.\n *\n * Example:\n * ```\n * import {forProp, handle, log} from '@enact/core/handle';\n *\n * const logWhenChecked = handle(\n *   forProp('checked', true),\n *   log('checked props is true')\n * );\n * ```\n *\n * @method   log\n * @param    {String}     message  Custom message\n * @param    {Object}     ev       Event payload\n * @param    {...*}       [args]   Any args passed are logged\n *\n * @returns  {true}                Always returns `true`\n * @curried\n * @memberof core/handle\n * @public\n */\n\nexports.forProp = forProp;\nvar log = handle.log = (0, _curry[\"default\"])(function (message, ev) {\n  if (process.env.NODE_ENV !== \"production\") {\n    var _console;\n\n    for (var _len5 = arguments.length, args = new Array(_len5 > 2 ? _len5 - 2 : 0), _key5 = 2; _key5 < _len5; _key5++) {\n      args[_key5 - 2] = arguments[_key5];\n    }\n\n    // eslint-disable-next-line no-console\n    (_console = console).log.apply(_console, [message, ev].concat(args));\n  }\n\n  return true;\n});\n/**\n * Invokes a method by name on the component to which {@link core/handle.handle} is bound.\n *\n * If the methods exists on the object, it is called with the event, props, and context and its\n * return value is returned.\n *\n * If the method does not exist or handle isn't bound to an instance, it returns `false`.\n *\n * Example:\n * ```\n * import {call, handle, forProp} from '@enact/core/handle';\n *\n * const incrementIfEnabled = handle(\n *   forProp('disabled', false),\n *   call('increment')\n * );\n *\n * class Counter extends React.Component {\n *   constructor () {\n *     super();\n *\n *     this.handleIncrement = incrementIfEnabled.bind(this);\n *   }\n *\n *   render () {\n *     // ...\n *   }\n * }\n * ```\n *\n * @method   call\n * @param    {String}     method  Name of method\n *\n * @returns  {HandlerFunction}    Returns the value returned by `method`, or `false` if the method\n *                                does not exist\n * @memberof core/handle\n * @public\n */\n\nexports.log = log;\n\nvar call = function call(method) {\n  return named(function () {\n    if (this && this[method]) {\n      return this[method].apply(this, arguments);\n    }\n\n    return false;\n  }, 'call');\n};\n/**\n * Adapts an event with `adapter` before calling `handler`.\n *\n * The `adapter` function receives the same arguments as any handler. The value returned from\n * `adapter` is passed as the first argument to `handler` with the remaining arguments kept the\n * same. This is often useful to generate a custom event payload before forwarding on to a callback.\n *\n * Example:\n * ```\n * import {adaptEvent, forward} from '@enact/core/handle';\n *\n * // calls the onChange callback with an event payload containing a type and value member\n * const incrementAndChange = adaptEvent(\n * \t(ev, props) => ({\n * \t  type: 'onChange',\n * \t  value: props.value + 1\n * \t}),\n * \tforward('onChange')\n * )\n * ```\n *\n * @method   adaptEvent\n * @param    {EventAdapter}     adapter  Function to adapt the event payload\n * @param    {HandlerFunction}  handler  Handler to call with the handler function\n *\n * @returns  {HandlerFunction}           Returns an [event handler]{@link core/handle.HandlerFunction} (suitable for passing to handle) that returns the result of `handler`\n * @curried\n * @memberof core/handle\n * @public\n */\n\n\nexports.call = call;\nvar adaptEvent = handle.adaptEvent = (0, _curry[\"default\"])(function (adapter, handler) {\n  return named(function (ev) {\n    for (var _len6 = arguments.length, args = new Array(_len6 > 1 ? _len6 - 1 : 0), _key6 = 1; _key6 < _len6; _key6++) {\n      args[_key6 - 1] = arguments[_key6];\n    }\n\n    return handler.call.apply(handler, [this, adapter.call.apply(adapter, [this, ev].concat(args))].concat(args));\n  }, 'adaptEvent');\n});\n/**\n * Creates a handler that will forward the event to a function at `name` on `props`.\n *\n * If `adapter` is not specified, a new event payload will be generated with a `type` member with\n * the `name` of the custom event. If `adapter` is specified, the `type` member is added to the\n * value returned by `adapter`.\n *\n * The `adapter` function receives the same arguments as any handler. The value returned from\n * `adapter` is passed as the first argument to `handler` with the remaining arguments kept the\n * same. This is often useful to generate a custom event payload before forwarding on to a callback.\n *\n * Example:\n * ```\n * import {forwardCustom} from '@enact/core/handle';\n *\n * // calls the onChange callback with the event: {type: 'onChange'}\n * const forwardChange = forwardCustom('onChange');\n *\n * // calls the onChange callback with the event: {type: 'onChange', index}\n * const forwardChangeWithIndex = forwardCustom('onChange', (ev, {index}) => ({index}));\n * ```\n *\n * @method   forwardCustom\n * @param    {String}        name      Name of method on the `props`\n * @param    {EventAdapter}  [adapter] Function to adapt the event payload\n *\n * @returns  {HandlerFunction}         Returns an [event handler]{@link core/handle.EventHandler}\n *                                     (suitable for passing to handle or used directly within\n *                                     `handlers` in [kind]{@link core/kind}) that will forward the\n *                                     custom event.\n * @memberof core/handle\n * @public\n */\n\nexports.adaptEvent = adaptEvent;\n\nvar forwardCustom = handle.forwardCustom = function (name, adapter) {\n  return handle(adaptEvent(function () {\n    var ev = adapter ? adapter.apply(void 0, arguments) : null; // Handle either no adapter or a non-object return from the adapter\n\n    if (!ev || typeof ev !== 'object') {\n      ev = {};\n    }\n\n    ev.type = name;\n    return ev;\n  }, forward(name))).named('forwardCustom');\n};\n/**\n * Accepts a handler and returns the logical complement of the value returned from the handler.\n *\n * Example:\n * ```\n * import {forProp, forward, not, handle} from '@enact/core/handle';\n *\n * // calls the onChange callback when disabled is not true\n * const handleChange = handle(\n *  not(forProp('disabled', true)),\n *  forward('onChange')\n * )\n * ```\n *\n * @method   not\n * @param    {HandlerFunction}  handler  Handler to complement\n *\n * @returns  {HandlerFunction}           Returns an [event\n *                                       handler]{@link core/handle.HandlerFunction} (suitable for\n *                                       passing to handle) that returns the complement of the\n *                                       return value of `handler`\n * @curried\n * @memberof core/handle\n * @public\n */\n\n\nexports.forwardCustom = forwardCustom;\n\nvar not = handle.not = function (handler) {\n  return function () {\n    return !handler.apply(void 0, arguments);\n  };\n};\n\nexports.not = not;\nvar _default = handle;\nexports[\"default\"] = _default;"]},"metadata":{},"sourceType":"module"}