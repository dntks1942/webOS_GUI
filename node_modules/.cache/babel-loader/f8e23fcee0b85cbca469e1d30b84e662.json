{"ast":null,"code":"\"use strict\";\n\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\nexports.getNavigableTarget = getNavigableTarget;\nexports.getTargetByContainer = getTargetByContainer;\nexports.getTargetByDirectionFromElement = getTargetByDirectionFromElement;\nexports.getTargetByDirectionFromPosition = getTargetByDirectionFromPosition;\nexports.getTargetBySelector = getTargetBySelector;\nexports.isFocusable = isFocusable;\nexports.getNearestTargetFromPosition = void 0;\n\nvar _clamp = _interopRequireDefault(require(\"ramda/src/clamp\"));\n\nvar _last = _interopRequireDefault(require(\"ramda/src/last\"));\n\nvar _container = require(\"./container\");\n\nvar _navigate = _interopRequireDefault(require(\"./navigate\"));\n\nvar _utils = require(\"./utils\");\n\nfunction _interopRequireDefault(obj) {\n  return obj && obj.__esModule ? obj : {\n    \"default\": obj\n  };\n}\n\nfunction ownKeys(object, enumerableOnly) {\n  var keys = Object.keys(object);\n\n  if (Object.getOwnPropertySymbols) {\n    var symbols = Object.getOwnPropertySymbols(object);\n    if (enumerableOnly) symbols = symbols.filter(function (sym) {\n      return Object.getOwnPropertyDescriptor(object, sym).enumerable;\n    });\n    keys.push.apply(keys, symbols);\n  }\n\n  return keys;\n}\n\nfunction _objectSpread(target) {\n  for (var i = 1; i < arguments.length; i++) {\n    var source = arguments[i] != null ? arguments[i] : {};\n\n    if (i % 2) {\n      ownKeys(Object(source), true).forEach(function (key) {\n        _defineProperty(target, key, source[key]);\n      });\n    } else if (Object.getOwnPropertyDescriptors) {\n      Object.defineProperties(target, Object.getOwnPropertyDescriptors(source));\n    } else {\n      ownKeys(Object(source)).forEach(function (key) {\n        Object.defineProperty(target, key, Object.getOwnPropertyDescriptor(source, key));\n      });\n    }\n  }\n\n  return target;\n}\n\nfunction _defineProperty(obj, key, value) {\n  if (key in obj) {\n    Object.defineProperty(obj, key, {\n      value: value,\n      enumerable: true,\n      configurable: true,\n      writable: true\n    });\n  } else {\n    obj[key] = value;\n  }\n\n  return obj;\n}\n\nfunction _toConsumableArray(arr) {\n  return _arrayWithoutHoles(arr) || _iterableToArray(arr) || _unsupportedIterableToArray(arr) || _nonIterableSpread();\n}\n\nfunction _nonIterableSpread() {\n  throw new TypeError(\"Invalid attempt to spread non-iterable instance.\\nIn order to be iterable, non-array objects must have a [Symbol.iterator]() method.\");\n}\n\nfunction _unsupportedIterableToArray(o, minLen) {\n  if (!o) return;\n  if (typeof o === \"string\") return _arrayLikeToArray(o, minLen);\n  var n = Object.prototype.toString.call(o).slice(8, -1);\n  if (n === \"Object\" && o.constructor) n = o.constructor.name;\n  if (n === \"Map\" || n === \"Set\") return Array.from(o);\n  if (n === \"Arguments\" || /^(?:Ui|I)nt(?:8|16|32)(?:Clamped)?Array$/.test(n)) return _arrayLikeToArray(o, minLen);\n}\n\nfunction _iterableToArray(iter) {\n  if (typeof Symbol !== \"undefined\" && Symbol.iterator in Object(iter)) return Array.from(iter);\n}\n\nfunction _arrayWithoutHoles(arr) {\n  if (Array.isArray(arr)) return _arrayLikeToArray(arr);\n}\n\nfunction _arrayLikeToArray(arr, len) {\n  if (len == null || len > arr.length) len = arr.length;\n\n  for (var i = 0, arr2 = new Array(len); i < len; i++) {\n    arr2[i] = arr[i];\n  }\n\n  return arr2;\n}\n\nfunction isFocusable(elem) {\n  var containers = (0, _container.getContainersForNode)(elem);\n  var verifySelector = true;\n\n  for (var i = containers.length - 1; i >= 0; i--) {\n    var containerId = containers[i];\n\n    if (!(0, _container.isNavigable)(elem, containerId, verifySelector)) {\n      return false;\n    } // only verify selector for the first (immediate ancestor) container\n\n\n    verifySelector = false;\n  }\n\n  return true;\n}\n\nfunction getContainersToSearch(containerId) {\n  var range = [];\n\n  var addRange = function addRange(id) {\n    var config = (0, _container.getContainerConfig)(id);\n\n    if (id && range.indexOf(id) < 0 && config && !config.selectorDisabled) {\n      range.push(id);\n    }\n  };\n\n  if (containerId) {\n    addRange(containerId);\n  } else {\n    addRange((0, _container.getDefaultContainer)());\n    addRange((0, _container.getLastContainer)());\n\n    _toConsumableArray((0, _container.getAllContainerIds)()).map(addRange);\n  }\n\n  return range;\n}\n\nfunction getTargetByContainer(containerId, enterTo) {\n  return getContainersToSearch(containerId).reduce(function (next, id) {\n    return next || (0, _container.getContainerFocusTarget)(id, enterTo);\n  }, null);\n}\n\nfunction getTargetBySelector(selector) {\n  if (!selector) return null;\n\n  if (selector.charAt(0) === '@') {\n    var containerId = selector.length === 1 ? null : selector.substr(1);\n    return getTargetByContainer(containerId);\n  }\n\n  var next = (0, _utils.parseSelector)(selector)[0];\n\n  if (next) {\n    if ((0, _container.isContainer)(next)) {\n      return getTargetByContainer((0, _container.getContainerId)(next));\n    }\n\n    var nextContainerIds = (0, _container.getContainersForNode)(next);\n\n    if ((0, _container.isNavigable)(next, (0, _last[\"default\"])(nextContainerIds), true)) {\n      return next;\n    }\n  }\n\n  return null;\n}\n\nfunction isRestrictedContainer(containerId) {\n  var config = (0, _container.getContainerConfig)(containerId);\n  return config && (config.enterTo === 'last-focused' || config.enterTo === 'default-element');\n}\n\nfunction filterRects(elementRects, boundingRect) {\n  if (!boundingRect) {\n    return elementRects;\n  } // remove elements that are outside of boundingRect, if specified\n\n\n  return elementRects.filter(function (rect) {\n    if ((0, _container.isContainer)(rect.element)) {\n      // For containers, test intersection since they may be larger than the bounding rect\n      return (0, _utils.intersects)(boundingRect, rect);\n    } else {\n      // For elements, use contains with the center to include mostly visible elements\n      return (0, _utils.contains)(boundingRect, rect.center);\n    }\n  }).map(function (rect) {\n    var topUpdate = rect.top < boundingRect.top;\n    var bottomUpdate = rect.bottom > boundingRect.bottom;\n    var leftUpdate = rect.left < boundingRect.left;\n    var rightUpdate = rect.right > boundingRect.right; // if the element's rect is larger than the bounding rect, clamp it to the bounding rect and\n    // recalculate the center based on the new bounds.\n\n    if (topUpdate || bottomUpdate || leftUpdate || rightUpdate) {\n      var updated = _objectSpread(_objectSpread({}, rect), {}, {\n        center: _objectSpread({}, rect.center)\n      });\n\n      if (topUpdate) updated.top = boundingRect.top;\n      if (bottomUpdate) updated.bottom = boundingRect.bottom;\n      if (leftUpdate) updated.left = boundingRect.left;\n      if (rightUpdate) updated.right = boundingRect.right;\n\n      if (leftUpdate || rightUpdate) {\n        var centerX = updated.left + (updated.right - updated.left) / 2;\n        updated.center.x = updated.center.left = updated.center.right = centerX;\n      }\n\n      if (topUpdate || bottomUpdate) {\n        var centerY = updated.top + (updated.bottom - updated.top) / 2;\n        updated.center.y = updated.center.top = updated.center.bottom = centerY;\n      }\n\n      return updated;\n    }\n\n    return rect;\n  });\n}\n\nfunction getContainerContainingRect(elementRects, elementRect) {\n  // find candidates that are containers and *visually* contain element\n  var overlapping = elementRects.filter(function (rect) {\n    return (0, _container.isContainer)(rect.element) && (0, _utils.contains)(rect, elementRect);\n  }); // if the next element is a container AND the current element is *visually* contained within\n  // one of the candidate element, we need to ignore container `enterTo` preferences and\n  // retrieve its spottable descendants and try to navigate to them.\n\n  if (overlapping.length) {\n    return overlapping[0].element.dataset.spotlightId;\n  }\n\n  return false;\n}\n\nfunction getOverflowContainerRect(containerId) {\n  // if the target container has overflowing content, update the boundingRect to match its\n  // bounds to prevent finding elements within the container's hierarchy but not visible.\n  // This filter only applies when waterfalling to prevent filtering out elements that share\n  // a container tree with `element`\n  var nextConfig = (0, _container.getContainerConfig)(containerId);\n\n  if (nextConfig && nextConfig.overflow) {\n    return (0, _utils.getContainerRect)(containerId);\n  }\n}\n\nfunction getTargetInContainerByDirectionFromPosition(direction, containerId, positionRect, elementContainerIds, boundingRect) {\n  var elements = (0, _container.getDeepSpottableDescendants)(containerId);\n  var elementRects = filterRects((0, _utils.getRects)(elements), boundingRect);\n  var next = null;\n\n  var _loop = function _loop() {\n    var overlappingContainerId = getContainerContainingRect(elementRects, positionRect); // if the pointer is within a container that is a candidate element, we need to ignore container\n    // `enterTo` preferences and retrieve its spottable descendants and try to navigate to them.\n\n    if (overlappingContainerId) {\n      next = getTargetInContainerByDirectionFromPosition(direction, overlappingContainerId, positionRect, elementContainerIds, boundingRect);\n\n      if (!next) {\n        // filter out the container and try again\n        elementRects = elementRects.filter(function (rect) {\n          return rect.element.dataset.spotlightId !== overlappingContainerId;\n        });\n        return \"continue\";\n      } // found a target so break out and return\n\n\n      return \"break\";\n    } // try to navigate from position to one of the candidates in containerId\n\n\n    next = (0, _navigate[\"default\"])(positionRect, direction, elementRects, (0, _container.getContainerConfig)(containerId)); // if we match a container, recurse into it\n\n    if (next && (0, _container.isContainer)(next)) {\n      var nextContainerId = next.dataset.spotlightId; // need to cache this reference so we can filter it out later if necessary\n\n      var lastNavigated = next;\n      next = getTargetInContainerByDirectionFromPosition(direction, nextContainerId, positionRect, elementContainerIds, getOverflowContainerRect(nextContainerId) || boundingRect);\n\n      if (!next) {\n        // filter out the container and try again\n        elementRects = elementRects.filter(function (rect) {\n          return rect.element !== lastNavigated;\n        });\n        return \"continue\";\n      }\n    } // If we've met every condition and haven't explicitly retried the search via `continue`,\n    // break out and return\n\n\n    return \"break\";\n  };\n\n  while (elementRects.length > 0) {\n    var _ret = _loop();\n\n    if (_ret === \"continue\") continue;\n    if (_ret === \"break\") break;\n  }\n\n  return next;\n}\n\nfunction getTargetInContainerByDirectionFromElement(direction, containerId, element, elementRect, elementContainerIds, boundingRect) {\n  var elements = (0, _container.getDeepSpottableDescendants)(containerId); // shortcut for previous target from element if it were saved\n\n  var previous = (0, _container.getContainerPreviousTarget)(containerId, direction, element);\n\n  if (previous && elements.indexOf(previous) !== -1) {\n    return previous;\n  } // `spotlightOverflow` is a private, and likely temporary, API to allow a component within an\n  // spotlight container with `overflow: true` to be treated as if it were outside of the\n  // container. The result is that the candidates, `elements` are filtered by the bounds of the\n  // overflow container effectively hiding those that have overflowed and are visually hidden.\n  //\n  // Currently only used by moonstone/Scroller.Scrollbar as a means to allow 5-way navigation to\n  // escape the Scrollable from paging controls rather than focusing contents that are out of view\n\n\n  if (element.dataset.spotlightOverflow === 'ignore') {\n    boundingRect = getOverflowContainerRect(containerId) || boundingRect;\n  }\n\n  var elementRects = filterRects((0, _utils.getRects)(elements), boundingRect);\n  var next = null;\n\n  var _loop2 = function _loop2() {\n    var overlappingContainerId = getContainerContainingRect(elementRects, elementRect); // if the next element is a container AND the current element is *visually* contained within\n    // one of the candidate elements, we need to ignore container `enterTo` preferences and\n    // retrieve its spottable descendants and try to navigate to them.\n\n    if (overlappingContainerId) {\n      next = getTargetInContainerByDirectionFromElement(direction, overlappingContainerId, element, elementRect, elementContainerIds, boundingRect);\n\n      if (!next) {\n        // filter out the container and try again\n        elementRects = elementRects.filter(function (rect) {\n          return rect.element.dataset.spotlightId !== overlappingContainerId;\n        });\n        return \"continue\";\n      } // found a target so break out and return\n\n\n      return \"break\";\n    } // If one of the downstream containers is configured for partition, we use that\n    // container's bounds as the partition rect for navigation.\n\n\n    var partitionContainer = elementContainerIds.slice(elementContainerIds.indexOf(containerId) + 1).find(function (id) {\n      var cfg = (0, _container.getContainerConfig)(id);\n      return cfg && cfg.partition;\n    });\n    var partitionRect = elementRect;\n\n    if (partitionContainer) {\n      partitionRect = (0, _utils.getContainerRect)(partitionContainer);\n    } // try to navigate from element to one of the candidates in containerId\n\n\n    next = (0, _navigate[\"default\"])(elementRect, direction, elementRects, (0, _container.getContainerConfig)(containerId), partitionRect); // if we match a container,\n\n    if (next && (0, _container.isContainer)(next)) {\n      var nextContainerId = next.dataset.spotlightId; // need to cache this reference so we can filter it out later if necessary\n\n      var lastNavigated = next; // and it is restricted, return its target\n\n      if (isRestrictedContainer(nextContainerId)) {\n        next = getTargetByContainer(nextContainerId);\n      } else {\n        // otherwise, recurse into it\n        next = getTargetInContainerByDirectionFromElement(direction, nextContainerId, element, elementRect, elementContainerIds, getOverflowContainerRect(nextContainerId) || boundingRect);\n      }\n\n      if (!next) {\n        elementRects = elementRects.filter(function (rect) {\n          return rect.element !== lastNavigated;\n        });\n        return \"continue\";\n      }\n    } // If we've met every condition and haven't explicitly retried the search via `continue`,\n    // break out and return\n\n\n    return \"break\";\n  };\n\n  while (elementRects.length > 0) {\n    var _ret2 = _loop2();\n\n    if (_ret2 === \"continue\") continue;\n    if (_ret2 === \"break\") break;\n  }\n\n  return next;\n}\n\nfunction getTargetByDirectionFromElement(direction, element) {\n  var extSelector = element.getAttribute('data-spot-' + direction);\n\n  if (typeof extSelector === 'string') {\n    return getTargetBySelector(extSelector);\n  }\n\n  var elementRect = (0, _utils.getRect)(element);\n  var next = (0, _container.getNavigableContainersForNode)(element).reduceRight(function (result, containerId, index, elementContainerIds) {\n    result = result || getTargetInContainerByDirectionFromElement(direction, containerId, element, elementRect, elementContainerIds);\n\n    if (!result) {\n      result = getLeaveForTarget(containerId, direction); // To support a `leaveFor` configuration with navigation disallowed in the current\n      // `direction`, we return the current element to prevent further searches for a\n      // target in this reduction.\n\n      if (result === false) {\n        result = element;\n      }\n    }\n\n    return result;\n  }, null); // if the reduce above returns the original element, it means it hit a `leaveFor` config that\n  // prevents navigation so we enforce that here by returning null.\n\n  return next !== element ? next : null;\n}\n\nfunction getTargetByDirectionFromPosition(direction, position, containerId) {\n  var pointerRect = (0, _utils.getPointRect)(position);\n  return (0, _container.getNavigableContainersForNode)((0, _container.getContainerNode)(containerId)).reduceRight(function (result, id, index, elementContainerIds) {\n    return result || getTargetInContainerByDirectionFromPosition(direction, id, pointerRect, elementContainerIds);\n  }, null);\n}\n/**\n * Returns the target identified by the selector configured for the container identified by\n * `containerId` for the given `direction`. If the selector is an empty string, the method returns\n * `false` indicating that navigation isn't allowed out of the container in that direction.\n *\n * @param   {String}        containerId  Identifier for a container\n * @param   {String}        direction    Direction to navigate (up, down, left, right)\n *\n * @returns {Node|Boolean}               Target, if found, or `false` if navigation is disallowed\n * @private\n */\n\n\nfunction getLeaveForTarget(containerId, direction) {\n  var config = (0, _container.getContainerConfig)(containerId);\n\n  if (config) {\n    var target = config.restrict !== 'self-only' && config.leaveFor && config.leaveFor[direction];\n\n    if (typeof target === 'string') {\n      if (target === '') {\n        return false;\n      }\n\n      return getTargetBySelector(target);\n    }\n\n    var nextContainerIds = (0, _container.getContainersForNode)(target);\n\n    if ((0, _container.isNavigable)(target, (0, _last[\"default\"])(nextContainerIds))) {\n      return target;\n    }\n  }\n\n  return null;\n}\n\nfunction getNavigableTarget(target) {\n  if (target === document) return null;\n  var parent;\n\n  while (target && ((0, _container.isContainer)(target) || !isFocusable(target))) {\n    parent = target.parentNode;\n    target = parent === document ? null : parent; // calling isNavigable on document is problematic\n  }\n\n  return target;\n}\n\nvar getOffsetDistanceToTargetFromPosition = function getOffsetDistanceToTargetFromPosition(distance, direction, _ref, _ref2) {\n  var x = _ref.x,\n      y = _ref.y;\n  var left = _ref2.left,\n      right = _ref2.right,\n      top = _ref2.top,\n      bottom = _ref2.bottom;\n\n  if (direction === 'left' || direction === 'right') {\n    if (y > bottom) {\n      distance += y - bottom;\n    } else if (y < top) {\n      distance += top - y;\n    }\n  } else if (x > right) {\n    distance += x - right;\n  } else if (x < left) {\n    distance += left - x;\n  }\n\n  return distance;\n};\n\nvar getDistanceToTargetFromPosition = function getDistanceToTargetFromPosition(direction, position, elementRect) {\n  var x = position.x,\n      y = position.y;\n  var distance;\n\n  if (direction === 'left') {\n    distance = x - elementRect.right;\n  } else if (direction === 'right') {\n    distance = elementRect.left - x;\n  } else if (direction === 'up') {\n    distance = y - elementRect.bottom;\n  } else if (direction === 'down') {\n    distance = elementRect.top - y;\n  }\n\n  return getOffsetDistanceToTargetFromPosition((0, _clamp[\"default\"])(0, Math.abs(distance), distance), direction, position, elementRect);\n};\n\nvar getNearestTargetsInContainerFromPosition = function getNearestTargetsInContainerFromPosition(position, containerId) {\n  return ['up', 'left', 'right', 'down'].reduce(function (result, direction) {\n    var target = getTargetByDirectionFromPosition(direction, position, containerId);\n\n    if (target) {\n      result.push({\n        direction: direction,\n        target: target\n      });\n    }\n\n    return result;\n  }, []);\n};\n\nvar getNearestTargetInContainerFromPosition = function getNearestTargetInContainerFromPosition(position, containerId) {\n  var targets = getNearestTargetsInContainerFromPosition(position, containerId);\n\n  if (!targets.length) {\n    return;\n  }\n\n  targets.forEach(function (item) {\n    var direction = item.direction,\n        target = item.target;\n    item.distance = getDistanceToTargetFromPosition(direction, position, (0, _utils.getRect)(target));\n  });\n  targets.sort(function (a, b) {\n    return a.distance - b.distance;\n  });\n  return targets[0].target;\n};\n\nvar getNearestTargetFromPosition = function getNearestTargetFromPosition(position, containerId) {\n  return getNavigableTarget(document.elementFromPoint(position.x, position.y)) || getNearestTargetInContainerFromPosition(position, containerId);\n};\n\nexports.getNearestTargetFromPosition = getNearestTargetFromPosition;","map":{"version":3,"sources":["/Users/sonjaeseong/workspace/webOS/CARROT/webOS_GUI/node_modules/@enact/spotlight/src/target.js"],"names":["Object","defineProperty","exports","value","getNavigableTarget","getTargetByContainer","getTargetByDirectionFromElement","getTargetByDirectionFromPosition","getTargetBySelector","isFocusable","getNearestTargetFromPosition","_clamp","_interopRequireDefault","require","_last","_container","_navigate","_utils","obj","__esModule","ownKeys","object","enumerableOnly","keys","getOwnPropertySymbols","symbols","filter","sym","getOwnPropertyDescriptor","enumerable","push","apply","_objectSpread","target","i","arguments","length","source","forEach","key","_defineProperty","getOwnPropertyDescriptors","defineProperties","configurable","writable","_toConsumableArray","arr","_arrayWithoutHoles","_iterableToArray","_unsupportedIterableToArray","_nonIterableSpread","TypeError","o","minLen","_arrayLikeToArray","n","prototype","toString","call","slice","constructor","name","Array","from","test","iter","Symbol","iterator","isArray","len","arr2","elem","containers","getContainersForNode","verifySelector","containerId","isNavigable","getContainersToSearch","range","addRange","id","config","getContainerConfig","indexOf","selectorDisabled","getDefaultContainer","getLastContainer","getAllContainerIds","map","enterTo","reduce","next","getContainerFocusTarget","selector","charAt","substr","parseSelector","isContainer","getContainerId","nextContainerIds","isRestrictedContainer","filterRects","elementRects","boundingRect","rect","element","intersects","contains","center","topUpdate","top","bottomUpdate","bottom","leftUpdate","left","rightUpdate","right","updated","centerX","x","centerY","y","getContainerContainingRect","elementRect","overlapping","dataset","spotlightId","getOverflowContainerRect","nextConfig","overflow","getContainerRect","getTargetInContainerByDirectionFromPosition","direction","positionRect","elementContainerIds","elements","getDeepSpottableDescendants","getRects","_loop","overlappingContainerId","nextContainerId","lastNavigated","_ret","getTargetInContainerByDirectionFromElement","previous","getContainerPreviousTarget","spotlightOverflow","_loop2","partitionContainer","find","cfg","partition","partitionRect","_ret2","extSelector","getAttribute","getRect","getNavigableContainersForNode","reduceRight","result","index","getLeaveForTarget","position","pointerRect","getPointRect","getContainerNode","restrict","leaveFor","document","parent","parentNode","getOffsetDistanceToTargetFromPosition","distance","_ref","_ref2","getDistanceToTargetFromPosition","Math","abs","getNearestTargetsInContainerFromPosition","getNearestTargetInContainerFromPosition","targets","item","sort","a","b","elementFromPoint"],"mappings":"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","sourcesContent":["\"use strict\";\n\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\nexports.getNavigableTarget = getNavigableTarget;\nexports.getTargetByContainer = getTargetByContainer;\nexports.getTargetByDirectionFromElement = getTargetByDirectionFromElement;\nexports.getTargetByDirectionFromPosition = getTargetByDirectionFromPosition;\nexports.getTargetBySelector = getTargetBySelector;\nexports.isFocusable = isFocusable;\nexports.getNearestTargetFromPosition = void 0;\n\nvar _clamp = _interopRequireDefault(require(\"ramda/src/clamp\"));\n\nvar _last = _interopRequireDefault(require(\"ramda/src/last\"));\n\nvar _container = require(\"./container\");\n\nvar _navigate = _interopRequireDefault(require(\"./navigate\"));\n\nvar _utils = require(\"./utils\");\n\nfunction _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { \"default\": obj }; }\n\nfunction ownKeys(object, enumerableOnly) { var keys = Object.keys(object); if (Object.getOwnPropertySymbols) { var symbols = Object.getOwnPropertySymbols(object); if (enumerableOnly) symbols = symbols.filter(function (sym) { return Object.getOwnPropertyDescriptor(object, sym).enumerable; }); keys.push.apply(keys, symbols); } return keys; }\n\nfunction _objectSpread(target) { for (var i = 1; i < arguments.length; i++) { var source = arguments[i] != null ? arguments[i] : {}; if (i % 2) { ownKeys(Object(source), true).forEach(function (key) { _defineProperty(target, key, source[key]); }); } else if (Object.getOwnPropertyDescriptors) { Object.defineProperties(target, Object.getOwnPropertyDescriptors(source)); } else { ownKeys(Object(source)).forEach(function (key) { Object.defineProperty(target, key, Object.getOwnPropertyDescriptor(source, key)); }); } } return target; }\n\nfunction _defineProperty(obj, key, value) { if (key in obj) { Object.defineProperty(obj, key, { value: value, enumerable: true, configurable: true, writable: true }); } else { obj[key] = value; } return obj; }\n\nfunction _toConsumableArray(arr) { return _arrayWithoutHoles(arr) || _iterableToArray(arr) || _unsupportedIterableToArray(arr) || _nonIterableSpread(); }\n\nfunction _nonIterableSpread() { throw new TypeError(\"Invalid attempt to spread non-iterable instance.\\nIn order to be iterable, non-array objects must have a [Symbol.iterator]() method.\"); }\n\nfunction _unsupportedIterableToArray(o, minLen) { if (!o) return; if (typeof o === \"string\") return _arrayLikeToArray(o, minLen); var n = Object.prototype.toString.call(o).slice(8, -1); if (n === \"Object\" && o.constructor) n = o.constructor.name; if (n === \"Map\" || n === \"Set\") return Array.from(o); if (n === \"Arguments\" || /^(?:Ui|I)nt(?:8|16|32)(?:Clamped)?Array$/.test(n)) return _arrayLikeToArray(o, minLen); }\n\nfunction _iterableToArray(iter) { if (typeof Symbol !== \"undefined\" && Symbol.iterator in Object(iter)) return Array.from(iter); }\n\nfunction _arrayWithoutHoles(arr) { if (Array.isArray(arr)) return _arrayLikeToArray(arr); }\n\nfunction _arrayLikeToArray(arr, len) { if (len == null || len > arr.length) len = arr.length; for (var i = 0, arr2 = new Array(len); i < len; i++) { arr2[i] = arr[i]; } return arr2; }\n\nfunction isFocusable(elem) {\n  var containers = (0, _container.getContainersForNode)(elem);\n  var verifySelector = true;\n\n  for (var i = containers.length - 1; i >= 0; i--) {\n    var containerId = containers[i];\n\n    if (!(0, _container.isNavigable)(elem, containerId, verifySelector)) {\n      return false;\n    } // only verify selector for the first (immediate ancestor) container\n\n\n    verifySelector = false;\n  }\n\n  return true;\n}\n\nfunction getContainersToSearch(containerId) {\n  var range = [];\n\n  var addRange = function addRange(id) {\n    var config = (0, _container.getContainerConfig)(id);\n\n    if (id && range.indexOf(id) < 0 && config && !config.selectorDisabled) {\n      range.push(id);\n    }\n  };\n\n  if (containerId) {\n    addRange(containerId);\n  } else {\n    addRange((0, _container.getDefaultContainer)());\n    addRange((0, _container.getLastContainer)());\n\n    _toConsumableArray((0, _container.getAllContainerIds)()).map(addRange);\n  }\n\n  return range;\n}\n\nfunction getTargetByContainer(containerId, enterTo) {\n  return getContainersToSearch(containerId).reduce(function (next, id) {\n    return next || (0, _container.getContainerFocusTarget)(id, enterTo);\n  }, null);\n}\n\nfunction getTargetBySelector(selector) {\n  if (!selector) return null;\n\n  if (selector.charAt(0) === '@') {\n    var containerId = selector.length === 1 ? null : selector.substr(1);\n    return getTargetByContainer(containerId);\n  }\n\n  var next = (0, _utils.parseSelector)(selector)[0];\n\n  if (next) {\n    if ((0, _container.isContainer)(next)) {\n      return getTargetByContainer((0, _container.getContainerId)(next));\n    }\n\n    var nextContainerIds = (0, _container.getContainersForNode)(next);\n\n    if ((0, _container.isNavigable)(next, (0, _last[\"default\"])(nextContainerIds), true)) {\n      return next;\n    }\n  }\n\n  return null;\n}\n\nfunction isRestrictedContainer(containerId) {\n  var config = (0, _container.getContainerConfig)(containerId);\n  return config && (config.enterTo === 'last-focused' || config.enterTo === 'default-element');\n}\n\nfunction filterRects(elementRects, boundingRect) {\n  if (!boundingRect) {\n    return elementRects;\n  } // remove elements that are outside of boundingRect, if specified\n\n\n  return elementRects.filter(function (rect) {\n    if ((0, _container.isContainer)(rect.element)) {\n      // For containers, test intersection since they may be larger than the bounding rect\n      return (0, _utils.intersects)(boundingRect, rect);\n    } else {\n      // For elements, use contains with the center to include mostly visible elements\n      return (0, _utils.contains)(boundingRect, rect.center);\n    }\n  }).map(function (rect) {\n    var topUpdate = rect.top < boundingRect.top;\n    var bottomUpdate = rect.bottom > boundingRect.bottom;\n    var leftUpdate = rect.left < boundingRect.left;\n    var rightUpdate = rect.right > boundingRect.right; // if the element's rect is larger than the bounding rect, clamp it to the bounding rect and\n    // recalculate the center based on the new bounds.\n\n    if (topUpdate || bottomUpdate || leftUpdate || rightUpdate) {\n      var updated = _objectSpread(_objectSpread({}, rect), {}, {\n        center: _objectSpread({}, rect.center)\n      });\n\n      if (topUpdate) updated.top = boundingRect.top;\n      if (bottomUpdate) updated.bottom = boundingRect.bottom;\n      if (leftUpdate) updated.left = boundingRect.left;\n      if (rightUpdate) updated.right = boundingRect.right;\n\n      if (leftUpdate || rightUpdate) {\n        var centerX = updated.left + (updated.right - updated.left) / 2;\n        updated.center.x = updated.center.left = updated.center.right = centerX;\n      }\n\n      if (topUpdate || bottomUpdate) {\n        var centerY = updated.top + (updated.bottom - updated.top) / 2;\n        updated.center.y = updated.center.top = updated.center.bottom = centerY;\n      }\n\n      return updated;\n    }\n\n    return rect;\n  });\n}\n\nfunction getContainerContainingRect(elementRects, elementRect) {\n  // find candidates that are containers and *visually* contain element\n  var overlapping = elementRects.filter(function (rect) {\n    return (0, _container.isContainer)(rect.element) && (0, _utils.contains)(rect, elementRect);\n  }); // if the next element is a container AND the current element is *visually* contained within\n  // one of the candidate element, we need to ignore container `enterTo` preferences and\n  // retrieve its spottable descendants and try to navigate to them.\n\n  if (overlapping.length) {\n    return overlapping[0].element.dataset.spotlightId;\n  }\n\n  return false;\n}\n\nfunction getOverflowContainerRect(containerId) {\n  // if the target container has overflowing content, update the boundingRect to match its\n  // bounds to prevent finding elements within the container's hierarchy but not visible.\n  // This filter only applies when waterfalling to prevent filtering out elements that share\n  // a container tree with `element`\n  var nextConfig = (0, _container.getContainerConfig)(containerId);\n\n  if (nextConfig && nextConfig.overflow) {\n    return (0, _utils.getContainerRect)(containerId);\n  }\n}\n\nfunction getTargetInContainerByDirectionFromPosition(direction, containerId, positionRect, elementContainerIds, boundingRect) {\n  var elements = (0, _container.getDeepSpottableDescendants)(containerId);\n  var elementRects = filterRects((0, _utils.getRects)(elements), boundingRect);\n  var next = null;\n\n  var _loop = function _loop() {\n    var overlappingContainerId = getContainerContainingRect(elementRects, positionRect); // if the pointer is within a container that is a candidate element, we need to ignore container\n    // `enterTo` preferences and retrieve its spottable descendants and try to navigate to them.\n\n    if (overlappingContainerId) {\n      next = getTargetInContainerByDirectionFromPosition(direction, overlappingContainerId, positionRect, elementContainerIds, boundingRect);\n\n      if (!next) {\n        // filter out the container and try again\n        elementRects = elementRects.filter(function (rect) {\n          return rect.element.dataset.spotlightId !== overlappingContainerId;\n        });\n        return \"continue\";\n      } // found a target so break out and return\n\n\n      return \"break\";\n    } // try to navigate from position to one of the candidates in containerId\n\n\n    next = (0, _navigate[\"default\"])(positionRect, direction, elementRects, (0, _container.getContainerConfig)(containerId)); // if we match a container, recurse into it\n\n    if (next && (0, _container.isContainer)(next)) {\n      var nextContainerId = next.dataset.spotlightId; // need to cache this reference so we can filter it out later if necessary\n\n      var lastNavigated = next;\n      next = getTargetInContainerByDirectionFromPosition(direction, nextContainerId, positionRect, elementContainerIds, getOverflowContainerRect(nextContainerId) || boundingRect);\n\n      if (!next) {\n        // filter out the container and try again\n        elementRects = elementRects.filter(function (rect) {\n          return rect.element !== lastNavigated;\n        });\n        return \"continue\";\n      }\n    } // If we've met every condition and haven't explicitly retried the search via `continue`,\n    // break out and return\n\n\n    return \"break\";\n  };\n\n  while (elementRects.length > 0) {\n    var _ret = _loop();\n\n    if (_ret === \"continue\") continue;\n    if (_ret === \"break\") break;\n  }\n\n  return next;\n}\n\nfunction getTargetInContainerByDirectionFromElement(direction, containerId, element, elementRect, elementContainerIds, boundingRect) {\n  var elements = (0, _container.getDeepSpottableDescendants)(containerId); // shortcut for previous target from element if it were saved\n\n  var previous = (0, _container.getContainerPreviousTarget)(containerId, direction, element);\n\n  if (previous && elements.indexOf(previous) !== -1) {\n    return previous;\n  } // `spotlightOverflow` is a private, and likely temporary, API to allow a component within an\n  // spotlight container with `overflow: true` to be treated as if it were outside of the\n  // container. The result is that the candidates, `elements` are filtered by the bounds of the\n  // overflow container effectively hiding those that have overflowed and are visually hidden.\n  //\n  // Currently only used by moonstone/Scroller.Scrollbar as a means to allow 5-way navigation to\n  // escape the Scrollable from paging controls rather than focusing contents that are out of view\n\n\n  if (element.dataset.spotlightOverflow === 'ignore') {\n    boundingRect = getOverflowContainerRect(containerId) || boundingRect;\n  }\n\n  var elementRects = filterRects((0, _utils.getRects)(elements), boundingRect);\n  var next = null;\n\n  var _loop2 = function _loop2() {\n    var overlappingContainerId = getContainerContainingRect(elementRects, elementRect); // if the next element is a container AND the current element is *visually* contained within\n    // one of the candidate elements, we need to ignore container `enterTo` preferences and\n    // retrieve its spottable descendants and try to navigate to them.\n\n    if (overlappingContainerId) {\n      next = getTargetInContainerByDirectionFromElement(direction, overlappingContainerId, element, elementRect, elementContainerIds, boundingRect);\n\n      if (!next) {\n        // filter out the container and try again\n        elementRects = elementRects.filter(function (rect) {\n          return rect.element.dataset.spotlightId !== overlappingContainerId;\n        });\n        return \"continue\";\n      } // found a target so break out and return\n\n\n      return \"break\";\n    } // If one of the downstream containers is configured for partition, we use that\n    // container's bounds as the partition rect for navigation.\n\n\n    var partitionContainer = elementContainerIds.slice(elementContainerIds.indexOf(containerId) + 1).find(function (id) {\n      var cfg = (0, _container.getContainerConfig)(id);\n      return cfg && cfg.partition;\n    });\n    var partitionRect = elementRect;\n\n    if (partitionContainer) {\n      partitionRect = (0, _utils.getContainerRect)(partitionContainer);\n    } // try to navigate from element to one of the candidates in containerId\n\n\n    next = (0, _navigate[\"default\"])(elementRect, direction, elementRects, (0, _container.getContainerConfig)(containerId), partitionRect); // if we match a container,\n\n    if (next && (0, _container.isContainer)(next)) {\n      var nextContainerId = next.dataset.spotlightId; // need to cache this reference so we can filter it out later if necessary\n\n      var lastNavigated = next; // and it is restricted, return its target\n\n      if (isRestrictedContainer(nextContainerId)) {\n        next = getTargetByContainer(nextContainerId);\n      } else {\n        // otherwise, recurse into it\n        next = getTargetInContainerByDirectionFromElement(direction, nextContainerId, element, elementRect, elementContainerIds, getOverflowContainerRect(nextContainerId) || boundingRect);\n      }\n\n      if (!next) {\n        elementRects = elementRects.filter(function (rect) {\n          return rect.element !== lastNavigated;\n        });\n        return \"continue\";\n      }\n    } // If we've met every condition and haven't explicitly retried the search via `continue`,\n    // break out and return\n\n\n    return \"break\";\n  };\n\n  while (elementRects.length > 0) {\n    var _ret2 = _loop2();\n\n    if (_ret2 === \"continue\") continue;\n    if (_ret2 === \"break\") break;\n  }\n\n  return next;\n}\n\nfunction getTargetByDirectionFromElement(direction, element) {\n  var extSelector = element.getAttribute('data-spot-' + direction);\n\n  if (typeof extSelector === 'string') {\n    return getTargetBySelector(extSelector);\n  }\n\n  var elementRect = (0, _utils.getRect)(element);\n  var next = (0, _container.getNavigableContainersForNode)(element).reduceRight(function (result, containerId, index, elementContainerIds) {\n    result = result || getTargetInContainerByDirectionFromElement(direction, containerId, element, elementRect, elementContainerIds);\n\n    if (!result) {\n      result = getLeaveForTarget(containerId, direction); // To support a `leaveFor` configuration with navigation disallowed in the current\n      // `direction`, we return the current element to prevent further searches for a\n      // target in this reduction.\n\n      if (result === false) {\n        result = element;\n      }\n    }\n\n    return result;\n  }, null); // if the reduce above returns the original element, it means it hit a `leaveFor` config that\n  // prevents navigation so we enforce that here by returning null.\n\n  return next !== element ? next : null;\n}\n\nfunction getTargetByDirectionFromPosition(direction, position, containerId) {\n  var pointerRect = (0, _utils.getPointRect)(position);\n  return (0, _container.getNavigableContainersForNode)((0, _container.getContainerNode)(containerId)).reduceRight(function (result, id, index, elementContainerIds) {\n    return result || getTargetInContainerByDirectionFromPosition(direction, id, pointerRect, elementContainerIds);\n  }, null);\n}\n/**\n * Returns the target identified by the selector configured for the container identified by\n * `containerId` for the given `direction`. If the selector is an empty string, the method returns\n * `false` indicating that navigation isn't allowed out of the container in that direction.\n *\n * @param   {String}        containerId  Identifier for a container\n * @param   {String}        direction    Direction to navigate (up, down, left, right)\n *\n * @returns {Node|Boolean}               Target, if found, or `false` if navigation is disallowed\n * @private\n */\n\n\nfunction getLeaveForTarget(containerId, direction) {\n  var config = (0, _container.getContainerConfig)(containerId);\n\n  if (config) {\n    var target = config.restrict !== 'self-only' && config.leaveFor && config.leaveFor[direction];\n\n    if (typeof target === 'string') {\n      if (target === '') {\n        return false;\n      }\n\n      return getTargetBySelector(target);\n    }\n\n    var nextContainerIds = (0, _container.getContainersForNode)(target);\n\n    if ((0, _container.isNavigable)(target, (0, _last[\"default\"])(nextContainerIds))) {\n      return target;\n    }\n  }\n\n  return null;\n}\n\nfunction getNavigableTarget(target) {\n  if (target === document) return null;\n  var parent;\n\n  while (target && ((0, _container.isContainer)(target) || !isFocusable(target))) {\n    parent = target.parentNode;\n    target = parent === document ? null : parent; // calling isNavigable on document is problematic\n  }\n\n  return target;\n}\n\nvar getOffsetDistanceToTargetFromPosition = function getOffsetDistanceToTargetFromPosition(distance, direction, _ref, _ref2) {\n  var x = _ref.x,\n      y = _ref.y;\n  var left = _ref2.left,\n      right = _ref2.right,\n      top = _ref2.top,\n      bottom = _ref2.bottom;\n\n  if (direction === 'left' || direction === 'right') {\n    if (y > bottom) {\n      distance += y - bottom;\n    } else if (y < top) {\n      distance += top - y;\n    }\n  } else if (x > right) {\n    distance += x - right;\n  } else if (x < left) {\n    distance += left - x;\n  }\n\n  return distance;\n};\n\nvar getDistanceToTargetFromPosition = function getDistanceToTargetFromPosition(direction, position, elementRect) {\n  var x = position.x,\n      y = position.y;\n  var distance;\n\n  if (direction === 'left') {\n    distance = x - elementRect.right;\n  } else if (direction === 'right') {\n    distance = elementRect.left - x;\n  } else if (direction === 'up') {\n    distance = y - elementRect.bottom;\n  } else if (direction === 'down') {\n    distance = elementRect.top - y;\n  }\n\n  return getOffsetDistanceToTargetFromPosition((0, _clamp[\"default\"])(0, Math.abs(distance), distance), direction, position, elementRect);\n};\n\nvar getNearestTargetsInContainerFromPosition = function getNearestTargetsInContainerFromPosition(position, containerId) {\n  return ['up', 'left', 'right', 'down'].reduce(function (result, direction) {\n    var target = getTargetByDirectionFromPosition(direction, position, containerId);\n\n    if (target) {\n      result.push({\n        direction: direction,\n        target: target\n      });\n    }\n\n    return result;\n  }, []);\n};\n\nvar getNearestTargetInContainerFromPosition = function getNearestTargetInContainerFromPosition(position, containerId) {\n  var targets = getNearestTargetsInContainerFromPosition(position, containerId);\n\n  if (!targets.length) {\n    return;\n  }\n\n  targets.forEach(function (item) {\n    var direction = item.direction,\n        target = item.target;\n    item.distance = getDistanceToTargetFromPosition(direction, position, (0, _utils.getRect)(target));\n  });\n  targets.sort(function (a, b) {\n    return a.distance - b.distance;\n  });\n  return targets[0].target;\n};\n\nvar getNearestTargetFromPosition = function getNearestTargetFromPosition(position, containerId) {\n  return getNavigableTarget(document.elementFromPoint(position.x, position.y)) || getNearestTargetInContainerFromPosition(position, containerId);\n};\n\nexports.getNearestTargetFromPosition = getNearestTargetFromPosition;"]},"metadata":{},"sourceType":"module"}