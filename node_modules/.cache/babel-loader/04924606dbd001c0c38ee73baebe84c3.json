{"ast":null,"code":"\"use strict\";\n\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\nexports.RouteContext = exports.toSegments = exports.stringifyRoutes = exports.resolve = exports.propTypes = void 0;\n\nvar _propTypes = _interopRequireDefault(require(\"prop-types\"));\n\nvar _react = _interopRequireDefault(require(\"react\"));\n\nfunction _interopRequireDefault(obj) {\n  return obj && obj.__esModule ? obj : {\n    \"default\": obj\n  };\n}\n\nvar RouteContext = /*#__PURE__*/_react[\"default\"].createContext(null);\n\nexports.RouteContext = RouteContext;\n\nvar toSegments = function toSegments(path) {\n  return Array.isArray(path) ? path : path.split('/').filter(Boolean);\n};\n\nexports.toSegments = toSegments;\n\nvar getPaths = function getPaths(routes, base) {\n  var result = [];\n  Object.keys(routes).filter(function (s) {\n    return s[0] !== '$';\n  }).forEach(function (p) {\n    var path = base + '/' + p;\n    result.push(path);\n    result = result.concat(getPaths(routes[p], path));\n  });\n  return result;\n};\n\nvar stringifyRoutes = function stringifyRoutes(routes) {\n  var pad = '\\n\\t';\n  var paths = getPaths(routes, '');\n  return pad + paths.join(pad);\n}; // resolves path relative to base\n\n\nexports.stringifyRoutes = stringifyRoutes;\n\nvar resolve = function resolve() {\n  var base = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : '/';\n  var path = arguments.length > 1 ? arguments[1] : undefined; // We could resolve to base but we want to consider this an error condition\n\n  if (!path) return; // convert a base array to a string for simpler normalization\n\n  if (base instanceof Array) base = base.join('/'); // normalize base to have a leading slash\n\n  if (!base.startsWith('/')) base = '/' + base; // if path has a leading slash, it's an absolute path so return it\n\n  if (path.startsWith('/')) return path; // if path isn't absolute and doesn't begin with ., it's relative to the base\n\n  if (!path.startsWith('.')) return base + '/' + path; // convert to arrays remove empty paths from base\n\n  base = base.split('/').filter(Boolean);\n  path = path.split('/');\n\n  while (path.length > 0) {\n    var p = path.shift();\n\n    if (!p || p === '.') {\n      // if we have an empty path or a current directory path, continue\n      continue;\n    } else if (p === '..') {\n      // if we're down the root and we encounter a parent path, return\n      if (base.length === 0) return; // otherwise, remove a level from base\n\n      base.pop();\n    } else {\n      // put back the current element so it can be included in the output path\n      path.unshift(p);\n      break;\n    }\n  } // finally rebuild the path including the segment we just shifted\n\n\n  return \"/\".concat(base.concat(path).join('/'));\n};\n\nexports.resolve = resolve;\nvar propTypes = {\n  path: _propTypes[\"default\"].oneOfType([_propTypes[\"default\"].arrayOf(_propTypes[\"default\"].string), // array of path segments\n  _propTypes[\"default\"].string // URI-style path\n  ])\n};\nexports.propTypes = propTypes;","map":{"version":3,"sources":["/Users/sonjaeseong/workspace/webOS/CARROT/webOS_GUI/node_modules/@enact/ui/Routable/util.js"],"names":["Object","defineProperty","exports","value","RouteContext","toSegments","stringifyRoutes","resolve","propTypes","_propTypes","_interopRequireDefault","require","_react","obj","__esModule","createContext","path","Array","isArray","split","filter","Boolean","getPaths","routes","base","result","keys","s","forEach","p","push","concat","pad","paths","join","arguments","length","undefined","startsWith","shift","pop","unshift","oneOfType","arrayOf","string"],"mappings":"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","sourcesContent":["\"use strict\";\n\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\nexports.RouteContext = exports.toSegments = exports.stringifyRoutes = exports.resolve = exports.propTypes = void 0;\n\nvar _propTypes = _interopRequireDefault(require(\"prop-types\"));\n\nvar _react = _interopRequireDefault(require(\"react\"));\n\nfunction _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { \"default\": obj }; }\n\nvar RouteContext = /*#__PURE__*/_react[\"default\"].createContext(null);\n\nexports.RouteContext = RouteContext;\n\nvar toSegments = function toSegments(path) {\n  return Array.isArray(path) ? path : path.split('/').filter(Boolean);\n};\n\nexports.toSegments = toSegments;\n\nvar getPaths = function getPaths(routes, base) {\n  var result = [];\n  Object.keys(routes).filter(function (s) {\n    return s[0] !== '$';\n  }).forEach(function (p) {\n    var path = base + '/' + p;\n    result.push(path);\n    result = result.concat(getPaths(routes[p], path));\n  });\n  return result;\n};\n\nvar stringifyRoutes = function stringifyRoutes(routes) {\n  var pad = '\\n\\t';\n  var paths = getPaths(routes, '');\n  return pad + paths.join(pad);\n}; // resolves path relative to base\n\n\nexports.stringifyRoutes = stringifyRoutes;\n\nvar resolve = function resolve() {\n  var base = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : '/';\n  var path = arguments.length > 1 ? arguments[1] : undefined;\n  // We could resolve to base but we want to consider this an error condition\n  if (!path) return; // convert a base array to a string for simpler normalization\n\n  if (base instanceof Array) base = base.join('/'); // normalize base to have a leading slash\n\n  if (!base.startsWith('/')) base = '/' + base; // if path has a leading slash, it's an absolute path so return it\n\n  if (path.startsWith('/')) return path; // if path isn't absolute and doesn't begin with ., it's relative to the base\n\n  if (!path.startsWith('.')) return base + '/' + path; // convert to arrays remove empty paths from base\n\n  base = base.split('/').filter(Boolean);\n  path = path.split('/');\n\n  while (path.length > 0) {\n    var p = path.shift();\n\n    if (!p || p === '.') {\n      // if we have an empty path or a current directory path, continue\n      continue;\n    } else if (p === '..') {\n      // if we're down the root and we encounter a parent path, return\n      if (base.length === 0) return; // otherwise, remove a level from base\n\n      base.pop();\n    } else {\n      // put back the current element so it can be included in the output path\n      path.unshift(p);\n      break;\n    }\n  } // finally rebuild the path including the segment we just shifted\n\n\n  return \"/\".concat(base.concat(path).join('/'));\n};\n\nexports.resolve = resolve;\nvar propTypes = {\n  path: _propTypes[\"default\"].oneOfType([_propTypes[\"default\"].arrayOf(_propTypes[\"default\"].string), // array of path segments\n  _propTypes[\"default\"].string // URI-style path\n  ])\n};\nexports.propTypes = propTypes;"]},"metadata":{},"sourceType":"module"}