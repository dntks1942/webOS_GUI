{"ast":null,"code":"\"use strict\";\n\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\nexports.getPosition = exports.getLabelOffset = exports.calcOverflow = exports.adjustAnchor = exports.adjustDirection = void 0;\n\nvar _resolution = _interopRequireDefault(require(\"@enact/ui/resolution\"));\n\nfunction _interopRequireDefault(obj) {\n  return obj && obj.__esModule ? obj : {\n    \"default\": obj\n  };\n} // TooltipDecorator util.js\n//\n\n/**\n * Calculates the unusable space of a centered Tooltip, which the Tooltip arrow cannot be positioned,\n * as a percentage of the Tooltip's total width.\n *\n * @param  {Number} tooltipWidth        The measured width of the Tooltip\n * @return {Number}                     The percent of the width of the tooltip that the Tooltip's\n *                                      decorations allocate for themselves (on one side).\n * @private\n */\n\n\nvar getLabelUnavailableSpace = function getLabelUnavailableSpace(tooltipWidth) {\n  // Arrow is 15px wide total, we need to know how wide half of it is, since it's centered on the anchor point.\n  var arrowWidth = 15 / 2; // Tooltip is 54px tall, divide by half to get the curve radius ,add the tooltip width\n  // to determine the distance that the anchor cannot progress past.\n\n  var tooltipUnavailableEdge = _resolution[\"default\"].scale(54 / 2 + arrowWidth); // cap the offset at 50% - that percentage\n\n\n  var tooltipUnavaliablePercentage = 0.5 - tooltipUnavailableEdge / tooltipWidth;\n  return tooltipUnavaliablePercentage;\n};\n/**\n * Adjust anchor position for `Tooltip` based on overflow and rtl.\n * Takes the output of `adjustDirection`, and `calcOverflow`.\n *\n * @method\n * @memberof moonstone/TooltipDecorator\n * @param   {String}  arrowAnchor       Initial anchor position\n * @param   {String}  tooltipDirection  Direction of tooltip; value from `adjustDirection`\n * @param   {Object}  overflow          Tooltip's calculated overflow from `calcOverflow`\n * @param   {Boolean} rtl               RTL mode\n * @returns {String}                    Adjusted anchor position\n * @private\n */\n\n\nvar adjustAnchor = function adjustAnchor(arrowAnchor, tooltipDirection, overflow, rtl) {\n  if (tooltipDirection === 'above' || tooltipDirection === 'below') {\n    if (rtl && arrowAnchor !== 'center') {\n      arrowAnchor = arrowAnchor === 'left' ? 'right' : 'left';\n    } // Flip sideways if it overflows to the sides\n\n\n    if (arrowAnchor === 'center') {// If tooltip is anchored in the center, don't flip. We'll offset it appropriately later.\n    } else if (overflow.isOverRight) {\n      arrowAnchor = 'left';\n    } else if (overflow.isOverLeft) {\n      arrowAnchor = 'right';\n    } // If tooltip is just too wide for the whole screen, switch it to a center tooltip\n\n\n    if (overflow.isOverWide && tooltipDirection !== 'left' && tooltipDirection !== 'right') {\n      arrowAnchor = 'center';\n    }\n  }\n\n  return arrowAnchor;\n};\n/**\n * Adjust direction for `Tooltip` based on overflow and rtl.\n * Takes the output from `calcOverflow`.\n *\n * @method\n * @memberof moonstone/TooltipDecorator\n * @param   {String}  tooltipDirection  Direction of tooltip\n * @param   {Object}  overflow          Tooltip's calculated overflow from `calcOverflow`\n * @param   {Boolean} rtl               RTL mode\n * @returns {String}                    Adjusted tooltip direction\n * @private\n */\n\n\nexports.adjustAnchor = adjustAnchor;\n\nvar adjustDirection = function adjustDirection(tooltipDirection, overflow, rtl) {\n  if (rtl && (tooltipDirection === 'left' || tooltipDirection === 'right')) {\n    tooltipDirection = tooltipDirection === 'left' ? 'right' : 'left';\n  } // Flip tooltip if it overflows towards the tooltip direction\n\n\n  if (overflow.isOverTop && tooltipDirection === 'above') {\n    tooltipDirection = 'below';\n  } else if (overflow.isOverBottom && tooltipDirection === 'below') {\n    tooltipDirection = 'above';\n  } else if (overflow.isOverLeft && tooltipDirection === 'left' && !overflow.isOverWide) {\n    tooltipDirection = 'right';\n  } else if (overflow.isOverRight && tooltipDirection === 'right' && !overflow.isOverWide) {\n    tooltipDirection = 'left';\n  }\n\n  return tooltipDirection;\n};\n/**\n * Calculates the overflow of `Tooltip` — if `Tooltip` is at the edge of the viewport.\n * Return the amount of overflow in a particular direction if there is overflow (false otherwise).\n *\n * @method\n * @memberof moonstone/TooltipDecorator\n * @param   {Object} tooltipNode        The `getBoundingClientRect` values for tooltip node\n * @param   {Object} clientNode         The `getBoundingClientRect` values for client node\n * @param   {String} tooltipDirection   Direction of tooltip\n * @param   {Number} tooltipHeight      Tooltip height\n * @param   {Number} edgeKeepout        Extra margin around the screen to avoid\n * @returns {Object}                    Tooltip's calculated overflow\n * @private\n */\n\n\nexports.adjustDirection = adjustDirection;\n\nvar calcOverflow = function calcOverflow(tooltipNode, clientNode, tooltipDirection, edgeKeepout) {\n  // get the distance of space on both the right and left side of the client node. `clientNode.width / 2` because we want the tooltip to be positioned horizontally in middle of the client node.\n  var windowWidth = window.innerWidth;\n  var windowHeight = window.innerHeight;\n  var clientHorizontalCenter = clientNode.left + clientNode.width / 2;\n  var tooltipSafeWidth = tooltipNode.width + edgeKeepout;\n  var tooltipCenterdSafeWidth = tooltipNode.width / 2 + edgeKeepout;\n  var rightDelta = tooltipSafeWidth > clientHorizontalCenter;\n  var leftDelta = tooltipSafeWidth > windowWidth - clientHorizontalCenter;\n  var isTooltipWide = tooltipSafeWidth > windowWidth || leftDelta && rightDelta;\n\n  if (tooltipDirection === 'above' || tooltipDirection === 'below') {\n    var isOverTop = clientNode.top - tooltipNode.height - edgeKeepout;\n    var isOverBottom = clientNode.bottom + tooltipNode.height + edgeKeepout;\n    var isOverLeft = clientHorizontalCenter - tooltipSafeWidth;\n    var isOverRight = clientHorizontalCenter + tooltipSafeWidth;\n    var isOverCenterLeft = clientHorizontalCenter - tooltipCenterdSafeWidth;\n    var isOverCenterRight = clientHorizontalCenter + tooltipCenterdSafeWidth;\n    return {\n      isOverTop: isOverTop < 0 ? isOverTop : false,\n      isOverBottom: isOverBottom > windowHeight ? isOverBottom - windowHeight : false,\n      isOverLeft: isOverLeft < 0 ? isOverLeft : false,\n      isOverRight: isOverRight > windowWidth ? isOverRight - windowWidth : false,\n      isOverCenterLeft: isOverCenterLeft < 0 ? isOverCenterLeft : false,\n      isOverCenterRight: isOverCenterRight > windowWidth ? isOverCenterRight - windowWidth : false,\n      isOverWide: isTooltipWide\n    };\n  } else if (tooltipDirection === 'left' || tooltipDirection === 'right') {\n    var _isOverTop = clientNode.top - tooltipNode.height + clientNode.height - edgeKeepout;\n\n    var _isOverBottom = clientNode.bottom + tooltipNode.height - clientNode.height / 2 + edgeKeepout;\n\n    var _isOverLeft = clientNode.left - tooltipNode.width - edgeKeepout;\n\n    var _isOverRight = clientNode.right + tooltipNode.width + edgeKeepout;\n\n    return {\n      isOverTop: _isOverTop < 0 ? _isOverTop : false,\n      isOverBottom: _isOverBottom > windowHeight ? _isOverBottom - windowHeight : false,\n      isOverLeft: _isOverLeft < 0 ? _isOverLeft : false,\n      isOverRight: _isOverRight > windowWidth ? _isOverRight - windowWidth : false,\n      isOverWide: isTooltipWide\n    };\n  }\n};\n/**\n * Calculates the top and left position for `Tooltip`.\n * Takes the output of `adjustAnchor`, `adjustDirection`, and `calcOverflow`.\n *\n * @method\n * @memberof moonstone/TooltipDecorator\n * @param   {Object} tooltipNode        The `getBoundingClientRect` values for tooltip node\n * @param   {Object} clientNode         The `getBoundingClientRect` values for client node\n * @param   {String} arrowAnchor        Anchor position from `adjustAnchor`\n * @param   {String} tooltipDirection   Direction of tooltip\n * @param   {Number} tooltipHeight      Tooltip height\n * @param   {Object} overflow           Tooltip's calculated overflow from `calcOverflow`\n * @param   {Boolean} rtl               RTL mode\n * @returns {Object}                    Tooltip top and left position\n * @private\n */\n\n\nexports.calcOverflow = calcOverflow;\n\nvar getPosition = function getPosition(clientNode, tooltipDirection) {\n  var position = {};\n\n  switch (tooltipDirection) {\n    case 'above':\n      position.top = clientNode.top;\n      break;\n\n    case 'below':\n      position.top = clientNode.bottom;\n      break;\n\n    case 'right':\n      position.left = clientNode.right;\n      break;\n\n    case 'left':\n      position.left = clientNode.left;\n      break;\n\n    default:\n      position = {};\n  }\n\n  if (tooltipDirection === 'above' || tooltipDirection === 'below') {\n    position.left = clientNode.left + clientNode.width / 2;\n  } else if (tooltipDirection === 'left' || tooltipDirection === 'right') {\n    position.top = clientNode.top + clientNode.height / 2;\n  }\n\n  return position;\n};\n/**\n * Adjusts the `Tooltip` arrow anchor when the tooltip is too wide.\n * Takes the output of `calcOverflow`.\n *\n * @method\n * @memberof moonstone/TooltipDecorator\n * @param   {Object}  tooltipNode       The `getBoundingClientRect` values for tooltip node\n * @param   {String}  tooltipDirection  Direction of tooltip\n * @param   {Object}  tooltipPosition   Calculated tooltip position from `getPosition`\n * @param   {Object}  overflow          Tooltip's calculated overflow from `calcOverflow`\n * @private\n */\n\n\nexports.getPosition = getPosition;\n\nvar getLabelOffset = function getLabelOffset(tooltipNode, tooltipDirection, tooltipPosition, overflow) {\n  // This method is irrelevent to left and right anchored tooltips, skip entirely.\n  if (tooltipDirection !== 'left' && tooltipDirection !== 'right') {\n    var tooltipWidth = tooltipNode.width;\n\n    if (overflow.isOverWide || overflow.isOverCenterLeft || overflow.isOverCenterRight) {\n      var pixelOffset = 0;\n\n      if (overflow.isOverCenterLeft) {\n        // Start shifting the label to the right (negative offset)\n        pixelOffset = overflow.isOverCenterLeft;\n      } else if (overflow.isOverCenterRight) {\n        // Start shifting the label to the left (positive offset)\n        pixelOffset = overflow.isOverCenterRight;\n      }\n\n      var percentageOffset = pixelOffset / tooltipWidth * -1;\n      var offsetBoundaryPercentage = getLabelUnavailableSpace(tooltipWidth);\n      var cappedPercentageOffset = Math.max(offsetBoundaryPercentage * -1, Math.min(offsetBoundaryPercentage, percentageOffset));\n      return cappedPercentageOffset;\n    }\n  }\n\n  return null;\n};\n\nexports.getLabelOffset = getLabelOffset;","map":{"version":3,"sources":["/Users/sonjaeseong/workspace/webOS/CARROT/webOS_GUI/node_modules/@enact/moonstone/TooltipDecorator/util.js"],"names":["Object","defineProperty","exports","value","getPosition","getLabelOffset","calcOverflow","adjustAnchor","adjustDirection","_resolution","_interopRequireDefault","require","obj","__esModule","getLabelUnavailableSpace","tooltipWidth","arrowWidth","tooltipUnavailableEdge","scale","tooltipUnavaliablePercentage","arrowAnchor","tooltipDirection","overflow","rtl","isOverRight","isOverLeft","isOverWide","isOverTop","isOverBottom","tooltipNode","clientNode","edgeKeepout","windowWidth","window","innerWidth","windowHeight","innerHeight","clientHorizontalCenter","left","width","tooltipSafeWidth","tooltipCenterdSafeWidth","rightDelta","leftDelta","isTooltipWide","top","height","bottom","isOverCenterLeft","isOverCenterRight","_isOverTop","_isOverBottom","_isOverLeft","_isOverRight","right","position","tooltipPosition","pixelOffset","percentageOffset","offsetBoundaryPercentage","cappedPercentageOffset","Math","max","min"],"mappings":"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","sourcesContent":["\"use strict\";\n\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\nexports.getPosition = exports.getLabelOffset = exports.calcOverflow = exports.adjustAnchor = exports.adjustDirection = void 0;\n\nvar _resolution = _interopRequireDefault(require(\"@enact/ui/resolution\"));\n\nfunction _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { \"default\": obj }; }\n\n// TooltipDecorator util.js\n//\n\n/**\n * Calculates the unusable space of a centered Tooltip, which the Tooltip arrow cannot be positioned,\n * as a percentage of the Tooltip's total width.\n *\n * @param  {Number} tooltipWidth        The measured width of the Tooltip\n * @return {Number}                     The percent of the width of the tooltip that the Tooltip's\n *                                      decorations allocate for themselves (on one side).\n * @private\n */\nvar getLabelUnavailableSpace = function getLabelUnavailableSpace(tooltipWidth) {\n  // Arrow is 15px wide total, we need to know how wide half of it is, since it's centered on the anchor point.\n  var arrowWidth = 15 / 2; // Tooltip is 54px tall, divide by half to get the curve radius ,add the tooltip width\n  // to determine the distance that the anchor cannot progress past.\n\n  var tooltipUnavailableEdge = _resolution[\"default\"].scale(54 / 2 + arrowWidth); // cap the offset at 50% - that percentage\n\n\n  var tooltipUnavaliablePercentage = 0.5 - tooltipUnavailableEdge / tooltipWidth;\n  return tooltipUnavaliablePercentage;\n};\n/**\n * Adjust anchor position for `Tooltip` based on overflow and rtl.\n * Takes the output of `adjustDirection`, and `calcOverflow`.\n *\n * @method\n * @memberof moonstone/TooltipDecorator\n * @param   {String}  arrowAnchor       Initial anchor position\n * @param   {String}  tooltipDirection  Direction of tooltip; value from `adjustDirection`\n * @param   {Object}  overflow          Tooltip's calculated overflow from `calcOverflow`\n * @param   {Boolean} rtl               RTL mode\n * @returns {String}                    Adjusted anchor position\n * @private\n */\n\n\nvar adjustAnchor = function adjustAnchor(arrowAnchor, tooltipDirection, overflow, rtl) {\n  if (tooltipDirection === 'above' || tooltipDirection === 'below') {\n    if (rtl && arrowAnchor !== 'center') {\n      arrowAnchor = arrowAnchor === 'left' ? 'right' : 'left';\n    } // Flip sideways if it overflows to the sides\n\n\n    if (arrowAnchor === 'center') {// If tooltip is anchored in the center, don't flip. We'll offset it appropriately later.\n    } else if (overflow.isOverRight) {\n      arrowAnchor = 'left';\n    } else if (overflow.isOverLeft) {\n      arrowAnchor = 'right';\n    } // If tooltip is just too wide for the whole screen, switch it to a center tooltip\n\n\n    if (overflow.isOverWide && tooltipDirection !== 'left' && tooltipDirection !== 'right') {\n      arrowAnchor = 'center';\n    }\n  }\n\n  return arrowAnchor;\n};\n/**\n * Adjust direction for `Tooltip` based on overflow and rtl.\n * Takes the output from `calcOverflow`.\n *\n * @method\n * @memberof moonstone/TooltipDecorator\n * @param   {String}  tooltipDirection  Direction of tooltip\n * @param   {Object}  overflow          Tooltip's calculated overflow from `calcOverflow`\n * @param   {Boolean} rtl               RTL mode\n * @returns {String}                    Adjusted tooltip direction\n * @private\n */\n\n\nexports.adjustAnchor = adjustAnchor;\n\nvar adjustDirection = function adjustDirection(tooltipDirection, overflow, rtl) {\n  if (rtl && (tooltipDirection === 'left' || tooltipDirection === 'right')) {\n    tooltipDirection = tooltipDirection === 'left' ? 'right' : 'left';\n  } // Flip tooltip if it overflows towards the tooltip direction\n\n\n  if (overflow.isOverTop && tooltipDirection === 'above') {\n    tooltipDirection = 'below';\n  } else if (overflow.isOverBottom && tooltipDirection === 'below') {\n    tooltipDirection = 'above';\n  } else if (overflow.isOverLeft && tooltipDirection === 'left' && !overflow.isOverWide) {\n    tooltipDirection = 'right';\n  } else if (overflow.isOverRight && tooltipDirection === 'right' && !overflow.isOverWide) {\n    tooltipDirection = 'left';\n  }\n\n  return tooltipDirection;\n};\n/**\n * Calculates the overflow of `Tooltip` — if `Tooltip` is at the edge of the viewport.\n * Return the amount of overflow in a particular direction if there is overflow (false otherwise).\n *\n * @method\n * @memberof moonstone/TooltipDecorator\n * @param   {Object} tooltipNode        The `getBoundingClientRect` values for tooltip node\n * @param   {Object} clientNode         The `getBoundingClientRect` values for client node\n * @param   {String} tooltipDirection   Direction of tooltip\n * @param   {Number} tooltipHeight      Tooltip height\n * @param   {Number} edgeKeepout        Extra margin around the screen to avoid\n * @returns {Object}                    Tooltip's calculated overflow\n * @private\n */\n\n\nexports.adjustDirection = adjustDirection;\n\nvar calcOverflow = function calcOverflow(tooltipNode, clientNode, tooltipDirection, edgeKeepout) {\n  // get the distance of space on both the right and left side of the client node. `clientNode.width / 2` because we want the tooltip to be positioned horizontally in middle of the client node.\n  var windowWidth = window.innerWidth;\n  var windowHeight = window.innerHeight;\n  var clientHorizontalCenter = clientNode.left + clientNode.width / 2;\n  var tooltipSafeWidth = tooltipNode.width + edgeKeepout;\n  var tooltipCenterdSafeWidth = tooltipNode.width / 2 + edgeKeepout;\n  var rightDelta = tooltipSafeWidth > clientHorizontalCenter;\n  var leftDelta = tooltipSafeWidth > windowWidth - clientHorizontalCenter;\n  var isTooltipWide = tooltipSafeWidth > windowWidth || leftDelta && rightDelta;\n\n  if (tooltipDirection === 'above' || tooltipDirection === 'below') {\n    var isOverTop = clientNode.top - tooltipNode.height - edgeKeepout;\n    var isOverBottom = clientNode.bottom + tooltipNode.height + edgeKeepout;\n    var isOverLeft = clientHorizontalCenter - tooltipSafeWidth;\n    var isOverRight = clientHorizontalCenter + tooltipSafeWidth;\n    var isOverCenterLeft = clientHorizontalCenter - tooltipCenterdSafeWidth;\n    var isOverCenterRight = clientHorizontalCenter + tooltipCenterdSafeWidth;\n    return {\n      isOverTop: isOverTop < 0 ? isOverTop : false,\n      isOverBottom: isOverBottom > windowHeight ? isOverBottom - windowHeight : false,\n      isOverLeft: isOverLeft < 0 ? isOverLeft : false,\n      isOverRight: isOverRight > windowWidth ? isOverRight - windowWidth : false,\n      isOverCenterLeft: isOverCenterLeft < 0 ? isOverCenterLeft : false,\n      isOverCenterRight: isOverCenterRight > windowWidth ? isOverCenterRight - windowWidth : false,\n      isOverWide: isTooltipWide\n    };\n  } else if (tooltipDirection === 'left' || tooltipDirection === 'right') {\n    var _isOverTop = clientNode.top - tooltipNode.height + clientNode.height - edgeKeepout;\n\n    var _isOverBottom = clientNode.bottom + tooltipNode.height - clientNode.height / 2 + edgeKeepout;\n\n    var _isOverLeft = clientNode.left - tooltipNode.width - edgeKeepout;\n\n    var _isOverRight = clientNode.right + tooltipNode.width + edgeKeepout;\n\n    return {\n      isOverTop: _isOverTop < 0 ? _isOverTop : false,\n      isOverBottom: _isOverBottom > windowHeight ? _isOverBottom - windowHeight : false,\n      isOverLeft: _isOverLeft < 0 ? _isOverLeft : false,\n      isOverRight: _isOverRight > windowWidth ? _isOverRight - windowWidth : false,\n      isOverWide: isTooltipWide\n    };\n  }\n};\n/**\n * Calculates the top and left position for `Tooltip`.\n * Takes the output of `adjustAnchor`, `adjustDirection`, and `calcOverflow`.\n *\n * @method\n * @memberof moonstone/TooltipDecorator\n * @param   {Object} tooltipNode        The `getBoundingClientRect` values for tooltip node\n * @param   {Object} clientNode         The `getBoundingClientRect` values for client node\n * @param   {String} arrowAnchor        Anchor position from `adjustAnchor`\n * @param   {String} tooltipDirection   Direction of tooltip\n * @param   {Number} tooltipHeight      Tooltip height\n * @param   {Object} overflow           Tooltip's calculated overflow from `calcOverflow`\n * @param   {Boolean} rtl               RTL mode\n * @returns {Object}                    Tooltip top and left position\n * @private\n */\n\n\nexports.calcOverflow = calcOverflow;\n\nvar getPosition = function getPosition(clientNode, tooltipDirection) {\n  var position = {};\n\n  switch (tooltipDirection) {\n    case 'above':\n      position.top = clientNode.top;\n      break;\n\n    case 'below':\n      position.top = clientNode.bottom;\n      break;\n\n    case 'right':\n      position.left = clientNode.right;\n      break;\n\n    case 'left':\n      position.left = clientNode.left;\n      break;\n\n    default:\n      position = {};\n  }\n\n  if (tooltipDirection === 'above' || tooltipDirection === 'below') {\n    position.left = clientNode.left + clientNode.width / 2;\n  } else if (tooltipDirection === 'left' || tooltipDirection === 'right') {\n    position.top = clientNode.top + clientNode.height / 2;\n  }\n\n  return position;\n};\n/**\n * Adjusts the `Tooltip` arrow anchor when the tooltip is too wide.\n * Takes the output of `calcOverflow`.\n *\n * @method\n * @memberof moonstone/TooltipDecorator\n * @param   {Object}  tooltipNode       The `getBoundingClientRect` values for tooltip node\n * @param   {String}  tooltipDirection  Direction of tooltip\n * @param   {Object}  tooltipPosition   Calculated tooltip position from `getPosition`\n * @param   {Object}  overflow          Tooltip's calculated overflow from `calcOverflow`\n * @private\n */\n\n\nexports.getPosition = getPosition;\n\nvar getLabelOffset = function getLabelOffset(tooltipNode, tooltipDirection, tooltipPosition, overflow) {\n  // This method is irrelevent to left and right anchored tooltips, skip entirely.\n  if (tooltipDirection !== 'left' && tooltipDirection !== 'right') {\n    var tooltipWidth = tooltipNode.width;\n\n    if (overflow.isOverWide || overflow.isOverCenterLeft || overflow.isOverCenterRight) {\n      var pixelOffset = 0;\n\n      if (overflow.isOverCenterLeft) {\n        // Start shifting the label to the right (negative offset)\n        pixelOffset = overflow.isOverCenterLeft;\n      } else if (overflow.isOverCenterRight) {\n        // Start shifting the label to the left (positive offset)\n        pixelOffset = overflow.isOverCenterRight;\n      }\n\n      var percentageOffset = pixelOffset / tooltipWidth * -1;\n      var offsetBoundaryPercentage = getLabelUnavailableSpace(tooltipWidth);\n      var cappedPercentageOffset = Math.max(offsetBoundaryPercentage * -1, Math.min(offsetBoundaryPercentage, percentageOffset));\n      return cappedPercentageOffset;\n    }\n  }\n\n  return null;\n};\n\nexports.getLabelOffset = getLabelOffset;"]},"metadata":{},"sourceType":"module"}