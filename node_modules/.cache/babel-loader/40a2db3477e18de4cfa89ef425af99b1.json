{"ast":null,"code":"\"use strict\";\n\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\nexports.wrapWithView = exports.View = exports[\"default\"] = void 0;\n\nvar _util = require(\"@enact/core/util\");\n\nvar _react = _interopRequireDefault(require(\"react\"));\n\nvar _propTypes = _interopRequireDefault(require(\"prop-types\"));\n\nvar _reactDom = _interopRequireDefault(require(\"react-dom\"));\n\nvar _Arranger = require(\"./Arranger\");\n\nfunction _interopRequireDefault(obj) {\n  return obj && obj.__esModule ? obj : {\n    \"default\": obj\n  };\n}\n\nfunction _classCallCheck(instance, Constructor) {\n  if (!(instance instanceof Constructor)) {\n    throw new TypeError(\"Cannot call a class as a function\");\n  }\n}\n\nfunction _defineProperties(target, props) {\n  for (var i = 0; i < props.length; i++) {\n    var descriptor = props[i];\n    descriptor.enumerable = descriptor.enumerable || false;\n    descriptor.configurable = true;\n    if (\"value\" in descriptor) descriptor.writable = true;\n    Object.defineProperty(target, descriptor.key, descriptor);\n  }\n}\n\nfunction _createClass(Constructor, protoProps, staticProps) {\n  if (protoProps) _defineProperties(Constructor.prototype, protoProps);\n  if (staticProps) _defineProperties(Constructor, staticProps);\n  return Constructor;\n}\n\nfunction _inherits(subClass, superClass) {\n  if (typeof superClass !== \"function\" && superClass !== null) {\n    throw new TypeError(\"Super expression must either be null or a function\");\n  }\n\n  subClass.prototype = Object.create(superClass && superClass.prototype, {\n    constructor: {\n      value: subClass,\n      writable: true,\n      configurable: true\n    }\n  });\n  if (superClass) _setPrototypeOf(subClass, superClass);\n}\n\nfunction _setPrototypeOf(o, p) {\n  _setPrototypeOf = Object.setPrototypeOf || function _setPrototypeOf(o, p) {\n    o.__proto__ = p;\n    return o;\n  };\n\n  return _setPrototypeOf(o, p);\n}\n\nfunction _createSuper(Derived) {\n  var hasNativeReflectConstruct = _isNativeReflectConstruct();\n\n  return function _createSuperInternal() {\n    var Super = _getPrototypeOf(Derived),\n        result;\n\n    if (hasNativeReflectConstruct) {\n      var NewTarget = _getPrototypeOf(this).constructor;\n\n      result = Reflect.construct(Super, arguments, NewTarget);\n    } else {\n      result = Super.apply(this, arguments);\n    }\n\n    return _possibleConstructorReturn(this, result);\n  };\n}\n\nfunction _possibleConstructorReturn(self, call) {\n  if (call && (typeof call === \"object\" || typeof call === \"function\")) {\n    return call;\n  }\n\n  return _assertThisInitialized(self);\n}\n\nfunction _assertThisInitialized(self) {\n  if (self === void 0) {\n    throw new ReferenceError(\"this hasn't been initialised - super() hasn't been called\");\n  }\n\n  return self;\n}\n\nfunction _isNativeReflectConstruct() {\n  if (typeof Reflect === \"undefined\" || !Reflect.construct) return false;\n  if (Reflect.construct.sham) return false;\n  if (typeof Proxy === \"function\") return true;\n\n  try {\n    Date.prototype.toString.call(Reflect.construct(Date, [], function () {}));\n    return true;\n  } catch (e) {\n    return false;\n  }\n}\n\nfunction _getPrototypeOf(o) {\n  _getPrototypeOf = Object.setPrototypeOf ? Object.getPrototypeOf : function _getPrototypeOf(o) {\n    return o.__proto__ || Object.getPrototypeOf(o);\n  };\n  return _getPrototypeOf(o);\n} // If the View was \"appearing\", then entering will always be false and this will not result in a\n// re-render. If the view should enter, state.enter will be true and this will toggle it to false\n// causing a re-render.\n\n\nvar clearEntering = function clearEntering(_ref) {\n  var entering = _ref.entering;\n  return entering ? {\n    entering: false\n  } : null;\n};\n/**\n * A `View` wraps a set of children for {@link ui/ViewManager.ViewManager}.\n * It is not intended to be used directly\n *\n * @class View\n * @memberof ui/ViewManager\n * @private\n */\n\n\nvar View = /*#__PURE__*/function (_React$Component) {\n  _inherits(View, _React$Component);\n\n  var _super = _createSuper(View);\n\n  function View(props) {\n    var _this;\n\n    _classCallCheck(this, View);\n\n    _this = _super.call(this, props);\n    _this.enteringJob = new _util.Job(function () {\n      _this.setState(clearEntering);\n    });\n\n    _this.prepareTransition = function (arranger, callback, noAnimation) {\n      var _this$props = _this.props,\n          duration = _this$props.duration,\n          index = _this$props.index,\n          _this$props$previousI = _this$props.previousIndex,\n          previousIndex = _this$props$previousI === void 0 ? index : _this$props$previousI,\n          reverseTransition = _this$props.reverseTransition,\n          rtl = _this$props.rtl; // Need to ensure that we have a valid node reference before we animation. Sometimes, React\n      // will replace the node after mount causing a reference cached there to be invalid.\n      // eslint-disable-next-line react/no-find-dom-node\n\n      _this.node = _reactDom[\"default\"].findDOMNode(_assertThisInitialized(_this));\n\n      if (_this.animation && _this.animation.playState !== 'finished' && _this.changeDirection) {\n        _this.animation.reverse();\n      } else {\n        _this.animation = arranger({\n          from: previousIndex,\n          node: _this.node,\n          reverse: reverseTransition,\n          rtl: rtl,\n          to: index,\n          fill: 'forwards',\n          duration: duration\n        });\n      } // Must set a new handler here to ensure the right callback is invoked\n\n\n      _this.animation.onfinish = function () {\n        _this.animation = null; // Possible for the animation callback to still be fired after the node has been\n        // unmounted if it finished before the unmount can cancel it so we check for that.\n\n        if (_this.node) {\n          callback();\n        }\n      }; // disable animation when the instance or props flag is true\n\n\n      if (noAnimation || _this.props.noAnimation) {\n        _this.animation.finish();\n      }\n    };\n\n    _this.animation = null;\n    _this.state = {\n      entering: !props.appearing\n    };\n    return _this;\n  }\n\n  _createClass(View, [{\n    key: \"shouldComponentUpdate\",\n    value: function shouldComponentUpdate(nextProps) {\n      if (nextProps.leaving) {\n        // FIXME: This is generally a bad practice to mutate local state in sCU but is necessary\n        // for the time being to ensure that a view that is reversed before it completes\n        // entering will transition correctly out of the viewport.\n        this.changeDirection = this.shouldChangeDirection(this.props, nextProps);\n        return false;\n      }\n\n      return true;\n    }\n  }, {\n    key: \"componentDidUpdate\",\n    value: function componentDidUpdate(prevProps) {\n      this.changeDirection = this.shouldChangeDirection(prevProps, this.props);\n    }\n  }, {\n    key: \"componentWillUnmount\",\n    value: function componentWillUnmount() {\n      this.enteringJob.stop();\n      this.node = null;\n\n      if (this.animation) {\n        this.animation.cancel();\n      }\n    }\n  }, {\n    key: \"shouldChangeDirection\",\n    value: function shouldChangeDirection(prevProps, nextProps) {\n      return this.animation ? prevProps.reverseTransition !== nextProps.reverseTransition : false;\n    }\n  }, {\n    key: \"componentWillAppear\",\n    value: function componentWillAppear(callback) {\n      var arranger = this.props.arranger;\n\n      if (arranger && arranger.stay) {\n        this.prepareTransition(arranger.stay, callback, true);\n      } else {\n        callback();\n      }\n    }\n  }, {\n    key: \"componentDidAppear\",\n    value: function componentDidAppear() {\n      this.setState(clearEntering);\n    } // This is called at the same time as componentDidMount() for components added to an existing\n    // TransitionGroup. It will block other animations from occurring until callback is called. It\n    // will not be called on the initial render of a TransitionGroup.\n\n  }, {\n    key: \"componentWillEnter\",\n    value: function componentWillEnter(callback) {\n      var _this$props2 = this.props,\n          appearing = _this$props2.appearing,\n          arranger = _this$props2.arranger,\n          reverseTransition = _this$props2.reverseTransition,\n          enteringProp = _this$props2.enteringProp; // This can happen if the panel was going to be removed and the animation was canceled,\n      // causing this panel to re-enter.\n\n      if (!appearing && enteringProp && !this.state.entering) {\n        this.setState({\n          entering: true\n        });\n      }\n\n      if (arranger) {\n        this.prepareTransition(reverseTransition ? arranger.leave : arranger.enter, callback);\n      } else {\n        callback();\n      }\n    }\n  }, {\n    key: \"componentDidEnter\",\n    value: function componentDidEnter() {\n      var _this$props3 = this.props,\n          enteringDelay = _this$props3.enteringDelay,\n          enteringProp = _this$props3.enteringProp;\n\n      if (enteringProp) {\n        // FIXME: `startRafAfter` is a temporary solution using rAF. We need a better way to handle\n        // transition cycle and component life cycle to be in sync. See ENYO-4835.\n        this.enteringJob.startRafAfter(enteringDelay);\n      }\n    }\n  }, {\n    key: \"componentWillStay\",\n    value: function componentWillStay(callback) {\n      var arranger = this.props.arranger;\n\n      if (arranger && arranger.stay) {\n        this.prepareTransition(arranger.stay, callback);\n      } else {\n        callback();\n      }\n    } // This is called when the child has been removed from the ReactTransitionGroup. Though the\n    // child has been removed, ReactTransitionGroup will keep it in the DOM until callback is\n    // called.\n\n  }, {\n    key: \"componentWillLeave\",\n    value: function componentWillLeave(callback) {\n      var _this$props4 = this.props,\n          arranger = _this$props4.arranger,\n          reverseTransition = _this$props4.reverseTransition;\n      this.enteringJob.stop();\n\n      if (arranger) {\n        this.prepareTransition(reverseTransition ? arranger.enter : arranger.leave, callback);\n      } else {\n        callback();\n      }\n    }\n    /**\n     * Initiates a new transition\n     *\n     * @param\t{Function}\tarranger\t\tArranger function to call (enter, leave)\n     * @param\t{Function}\tcallback\t\tCompletion callback\n     * @param\t{Boolean}\t[noAnimation]\t`true` to disable animation for this transition\n     * @returns {undefined}\n     * @private\n     */\n\n  }, {\n    key: \"render\",\n    value: function render() {\n      var _this$props5 = this.props,\n          enteringProp = _this$props5.enteringProp,\n          children = _this$props5.children,\n          childProps = _this$props5.childProps;\n\n      if (enteringProp || childProps) {\n        var props = Object.assign({}, childProps);\n\n        if (enteringProp) {\n          props[enteringProp] = this.state.entering;\n        }\n\n        return /*#__PURE__*/_react[\"default\"].cloneElement(children, props);\n      } else {\n        return _react[\"default\"].Children.only(children);\n      }\n    }\n  }]);\n\n  return View;\n}(_react[\"default\"].Component); // Not a true render method but instead a wrapper for TransitionGroup to wrap arbitrary children\n// with a TransitionGroup-compatible child that supports animation\n//\n// eslint-disable-next-line enact/display-name\n\n\nexports.View = View;\nView.propTypes =\n/** @lends ui/ViewManager.View.prototype */\n{\n  children: _propTypes[\"default\"].node.isRequired,\n\n  /**\n   * Time in milliseconds to complete a transition\n   *\n   * @type {Number}\n   * @required\n   * @public\n   */\n  duration: _propTypes[\"default\"].number.isRequired,\n\n  /**\n   * Set to `true` when the View should 'appear' without transitioning into the viewport\n   *\n   * @type {Boolean}\n   * @public\n   */\n  appearing: _propTypes[\"default\"].bool,\n\n  /**\n   * Arranger to control the animation\n   *\n   * @type {Arranger}\n   * @public\n   */\n  arranger: _Arranger.shape,\n\n  /**\n   * An object containing properties to be passed to each child.\n   *\n   * @type {Object}\n   * @public\n   */\n  childProps: _propTypes[\"default\"].object,\n\n  /**\n   * Time, in milliseconds, to wait after a view has entered to inform it by passing the\n   * `enteringProp` as `false`.\n   *\n   * @type {Number}\n   * @default 0\n   * @public\n   */\n  enteringDelay: _propTypes[\"default\"].number,\n\n  /**\n   * Name of the property to pass to the wrapped view to indicate when it is entering the\n   * viewport. When `true`, the view has been created but has not transitioned into place.\n   * When `false`, the view has finished its transition.\n   *\n   * The notification can be delayed by setting `enteringDelay`. If not set, the view will not\n   * be notified of the change in transition.\n   *\n   * @type {String}\n   * @public\n   */\n  enteringProp: _propTypes[\"default\"].string,\n\n  /**\n   * Index of the currently 'active' view.\n   *\n   * @type {Number}\n   */\n  index: _propTypes[\"default\"].number,\n\n  /**\n   * When `true`, indicates if a view is currently leaving.\n   *\n   * @type {Boolean}\n   */\n  leaving: _propTypes[\"default\"].bool,\n\n  /**\n   * When `true`, indicates if the transition should be animated\n   *\n   * @type {Boolean}\n   * @default true\n   * @public\n   */\n  noAnimation: _propTypes[\"default\"].bool,\n\n  /**\n   * Index of the previously 'active' view.\n   *\n   * @type {Number}\n   */\n  previousIndex: _propTypes[\"default\"].number,\n\n  /**\n   * When `true`, indicates if the transition should be reversed. The effect depends on how the provided\n   * `arranger` handles reversal.\n   *\n   * @type {Boolean}\n   * @default false\n   */\n  reverseTransition: _propTypes[\"default\"].bool,\n\n  /**\n   * When `true`, indicates the current locale uses right-to-left reading order.\n   *\n   * The effect depends on how the provided `arranger` handles this option.\n   *\n   * @type {Boolean}\n   */\n  rtl: _propTypes[\"default\"].bool\n};\nView.defaultProps = {\n  appearing: false,\n  enteringDelay: 0,\n  index: 0,\n  reverseTransition: false\n};\n\nvar wrapWithView = function wrapWithView(config) {\n  return function (child) {\n    return /*#__PURE__*/_react[\"default\"].createElement(View, config, child);\n  };\n};\n\nexports.wrapWithView = wrapWithView;\nvar _default = View;\nexports[\"default\"] = _default;","map":{"version":3,"sources":["/Users/sonjaeseong/workspace/webOS/CARROT/webOS_GUI/node_modules/@enact/ui/ViewManager/View.js"],"names":["Object","defineProperty","exports","value","wrapWithView","View","_util","require","_react","_interopRequireDefault","_propTypes","_reactDom","_Arranger","obj","__esModule","_classCallCheck","instance","Constructor","TypeError","_defineProperties","target","props","i","length","descriptor","enumerable","configurable","writable","key","_createClass","protoProps","staticProps","prototype","_inherits","subClass","superClass","create","constructor","_setPrototypeOf","o","p","setPrototypeOf","__proto__","_createSuper","Derived","hasNativeReflectConstruct","_isNativeReflectConstruct","_createSuperInternal","Super","_getPrototypeOf","result","NewTarget","Reflect","construct","arguments","apply","_possibleConstructorReturn","self","call","_assertThisInitialized","ReferenceError","sham","Proxy","Date","toString","e","getPrototypeOf","clearEntering","_ref","entering","_React$Component","_super","_this","enteringJob","Job","setState","prepareTransition","arranger","callback","noAnimation","_this$props","duration","index","_this$props$previousI","previousIndex","reverseTransition","rtl","node","findDOMNode","animation","playState","changeDirection","reverse","from","to","fill","onfinish","finish","state","appearing","shouldComponentUpdate","nextProps","leaving","shouldChangeDirection","componentDidUpdate","prevProps","componentWillUnmount","stop","cancel","componentWillAppear","stay","componentDidAppear","componentWillEnter","_this$props2","enteringProp","leave","enter","componentDidEnter","_this$props3","enteringDelay","startRafAfter","componentWillStay","componentWillLeave","_this$props4","render","_this$props5","children","childProps","assign","cloneElement","Children","only","Component","propTypes","isRequired","number","bool","shape","object","string","defaultProps","config","child","createElement","_default"],"mappings":"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","sourcesContent":["\"use strict\";\n\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\nexports.wrapWithView = exports.View = exports[\"default\"] = void 0;\n\nvar _util = require(\"@enact/core/util\");\n\nvar _react = _interopRequireDefault(require(\"react\"));\n\nvar _propTypes = _interopRequireDefault(require(\"prop-types\"));\n\nvar _reactDom = _interopRequireDefault(require(\"react-dom\"));\n\nvar _Arranger = require(\"./Arranger\");\n\nfunction _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { \"default\": obj }; }\n\nfunction _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError(\"Cannot call a class as a function\"); } }\n\nfunction _defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if (\"value\" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } }\n\nfunction _createClass(Constructor, protoProps, staticProps) { if (protoProps) _defineProperties(Constructor.prototype, protoProps); if (staticProps) _defineProperties(Constructor, staticProps); return Constructor; }\n\nfunction _inherits(subClass, superClass) { if (typeof superClass !== \"function\" && superClass !== null) { throw new TypeError(\"Super expression must either be null or a function\"); } subClass.prototype = Object.create(superClass && superClass.prototype, { constructor: { value: subClass, writable: true, configurable: true } }); if (superClass) _setPrototypeOf(subClass, superClass); }\n\nfunction _setPrototypeOf(o, p) { _setPrototypeOf = Object.setPrototypeOf || function _setPrototypeOf(o, p) { o.__proto__ = p; return o; }; return _setPrototypeOf(o, p); }\n\nfunction _createSuper(Derived) { var hasNativeReflectConstruct = _isNativeReflectConstruct(); return function _createSuperInternal() { var Super = _getPrototypeOf(Derived), result; if (hasNativeReflectConstruct) { var NewTarget = _getPrototypeOf(this).constructor; result = Reflect.construct(Super, arguments, NewTarget); } else { result = Super.apply(this, arguments); } return _possibleConstructorReturn(this, result); }; }\n\nfunction _possibleConstructorReturn(self, call) { if (call && (typeof call === \"object\" || typeof call === \"function\")) { return call; } return _assertThisInitialized(self); }\n\nfunction _assertThisInitialized(self) { if (self === void 0) { throw new ReferenceError(\"this hasn't been initialised - super() hasn't been called\"); } return self; }\n\nfunction _isNativeReflectConstruct() { if (typeof Reflect === \"undefined\" || !Reflect.construct) return false; if (Reflect.construct.sham) return false; if (typeof Proxy === \"function\") return true; try { Date.prototype.toString.call(Reflect.construct(Date, [], function () {})); return true; } catch (e) { return false; } }\n\nfunction _getPrototypeOf(o) { _getPrototypeOf = Object.setPrototypeOf ? Object.getPrototypeOf : function _getPrototypeOf(o) { return o.__proto__ || Object.getPrototypeOf(o); }; return _getPrototypeOf(o); }\n\n// If the View was \"appearing\", then entering will always be false and this will not result in a\n// re-render. If the view should enter, state.enter will be true and this will toggle it to false\n// causing a re-render.\nvar clearEntering = function clearEntering(_ref) {\n  var entering = _ref.entering;\n  return entering ? {\n    entering: false\n  } : null;\n};\n/**\n * A `View` wraps a set of children for {@link ui/ViewManager.ViewManager}.\n * It is not intended to be used directly\n *\n * @class View\n * @memberof ui/ViewManager\n * @private\n */\n\n\nvar View = /*#__PURE__*/function (_React$Component) {\n  _inherits(View, _React$Component);\n\n  var _super = _createSuper(View);\n\n  function View(props) {\n    var _this;\n\n    _classCallCheck(this, View);\n\n    _this = _super.call(this, props);\n    _this.enteringJob = new _util.Job(function () {\n      _this.setState(clearEntering);\n    });\n\n    _this.prepareTransition = function (arranger, callback, noAnimation) {\n      var _this$props = _this.props,\n          duration = _this$props.duration,\n          index = _this$props.index,\n          _this$props$previousI = _this$props.previousIndex,\n          previousIndex = _this$props$previousI === void 0 ? index : _this$props$previousI,\n          reverseTransition = _this$props.reverseTransition,\n          rtl = _this$props.rtl; // Need to ensure that we have a valid node reference before we animation. Sometimes, React\n      // will replace the node after mount causing a reference cached there to be invalid.\n      // eslint-disable-next-line react/no-find-dom-node\n\n      _this.node = _reactDom[\"default\"].findDOMNode(_assertThisInitialized(_this));\n\n      if (_this.animation && _this.animation.playState !== 'finished' && _this.changeDirection) {\n        _this.animation.reverse();\n      } else {\n        _this.animation = arranger({\n          from: previousIndex,\n          node: _this.node,\n          reverse: reverseTransition,\n          rtl: rtl,\n          to: index,\n          fill: 'forwards',\n          duration: duration\n        });\n      } // Must set a new handler here to ensure the right callback is invoked\n\n\n      _this.animation.onfinish = function () {\n        _this.animation = null; // Possible for the animation callback to still be fired after the node has been\n        // unmounted if it finished before the unmount can cancel it so we check for that.\n\n        if (_this.node) {\n          callback();\n        }\n      }; // disable animation when the instance or props flag is true\n\n\n      if (noAnimation || _this.props.noAnimation) {\n        _this.animation.finish();\n      }\n    };\n\n    _this.animation = null;\n    _this.state = {\n      entering: !props.appearing\n    };\n    return _this;\n  }\n\n  _createClass(View, [{\n    key: \"shouldComponentUpdate\",\n    value: function shouldComponentUpdate(nextProps) {\n      if (nextProps.leaving) {\n        // FIXME: This is generally a bad practice to mutate local state in sCU but is necessary\n        // for the time being to ensure that a view that is reversed before it completes\n        // entering will transition correctly out of the viewport.\n        this.changeDirection = this.shouldChangeDirection(this.props, nextProps);\n        return false;\n      }\n\n      return true;\n    }\n  }, {\n    key: \"componentDidUpdate\",\n    value: function componentDidUpdate(prevProps) {\n      this.changeDirection = this.shouldChangeDirection(prevProps, this.props);\n    }\n  }, {\n    key: \"componentWillUnmount\",\n    value: function componentWillUnmount() {\n      this.enteringJob.stop();\n      this.node = null;\n\n      if (this.animation) {\n        this.animation.cancel();\n      }\n    }\n  }, {\n    key: \"shouldChangeDirection\",\n    value: function shouldChangeDirection(prevProps, nextProps) {\n      return this.animation ? prevProps.reverseTransition !== nextProps.reverseTransition : false;\n    }\n  }, {\n    key: \"componentWillAppear\",\n    value: function componentWillAppear(callback) {\n      var arranger = this.props.arranger;\n\n      if (arranger && arranger.stay) {\n        this.prepareTransition(arranger.stay, callback, true);\n      } else {\n        callback();\n      }\n    }\n  }, {\n    key: \"componentDidAppear\",\n    value: function componentDidAppear() {\n      this.setState(clearEntering);\n    } // This is called at the same time as componentDidMount() for components added to an existing\n    // TransitionGroup. It will block other animations from occurring until callback is called. It\n    // will not be called on the initial render of a TransitionGroup.\n\n  }, {\n    key: \"componentWillEnter\",\n    value: function componentWillEnter(callback) {\n      var _this$props2 = this.props,\n          appearing = _this$props2.appearing,\n          arranger = _this$props2.arranger,\n          reverseTransition = _this$props2.reverseTransition,\n          enteringProp = _this$props2.enteringProp; // This can happen if the panel was going to be removed and the animation was canceled,\n      // causing this panel to re-enter.\n\n      if (!appearing && enteringProp && !this.state.entering) {\n        this.setState({\n          entering: true\n        });\n      }\n\n      if (arranger) {\n        this.prepareTransition(reverseTransition ? arranger.leave : arranger.enter, callback);\n      } else {\n        callback();\n      }\n    }\n  }, {\n    key: \"componentDidEnter\",\n    value: function componentDidEnter() {\n      var _this$props3 = this.props,\n          enteringDelay = _this$props3.enteringDelay,\n          enteringProp = _this$props3.enteringProp;\n\n      if (enteringProp) {\n        // FIXME: `startRafAfter` is a temporary solution using rAF. We need a better way to handle\n        // transition cycle and component life cycle to be in sync. See ENYO-4835.\n        this.enteringJob.startRafAfter(enteringDelay);\n      }\n    }\n  }, {\n    key: \"componentWillStay\",\n    value: function componentWillStay(callback) {\n      var arranger = this.props.arranger;\n\n      if (arranger && arranger.stay) {\n        this.prepareTransition(arranger.stay, callback);\n      } else {\n        callback();\n      }\n    } // This is called when the child has been removed from the ReactTransitionGroup. Though the\n    // child has been removed, ReactTransitionGroup will keep it in the DOM until callback is\n    // called.\n\n  }, {\n    key: \"componentWillLeave\",\n    value: function componentWillLeave(callback) {\n      var _this$props4 = this.props,\n          arranger = _this$props4.arranger,\n          reverseTransition = _this$props4.reverseTransition;\n      this.enteringJob.stop();\n\n      if (arranger) {\n        this.prepareTransition(reverseTransition ? arranger.enter : arranger.leave, callback);\n      } else {\n        callback();\n      }\n    }\n    /**\n     * Initiates a new transition\n     *\n     * @param\t{Function}\tarranger\t\tArranger function to call (enter, leave)\n     * @param\t{Function}\tcallback\t\tCompletion callback\n     * @param\t{Boolean}\t[noAnimation]\t`true` to disable animation for this transition\n     * @returns {undefined}\n     * @private\n     */\n\n  }, {\n    key: \"render\",\n    value: function render() {\n      var _this$props5 = this.props,\n          enteringProp = _this$props5.enteringProp,\n          children = _this$props5.children,\n          childProps = _this$props5.childProps;\n\n      if (enteringProp || childProps) {\n        var props = Object.assign({}, childProps);\n\n        if (enteringProp) {\n          props[enteringProp] = this.state.entering;\n        }\n\n        return /*#__PURE__*/_react[\"default\"].cloneElement(children, props);\n      } else {\n        return _react[\"default\"].Children.only(children);\n      }\n    }\n  }]);\n\n  return View;\n}(_react[\"default\"].Component); // Not a true render method but instead a wrapper for TransitionGroup to wrap arbitrary children\n// with a TransitionGroup-compatible child that supports animation\n//\n// eslint-disable-next-line enact/display-name\n\n\nexports.View = View;\nView.propTypes =\n/** @lends ui/ViewManager.View.prototype */\n{\n  children: _propTypes[\"default\"].node.isRequired,\n\n  /**\n   * Time in milliseconds to complete a transition\n   *\n   * @type {Number}\n   * @required\n   * @public\n   */\n  duration: _propTypes[\"default\"].number.isRequired,\n\n  /**\n   * Set to `true` when the View should 'appear' without transitioning into the viewport\n   *\n   * @type {Boolean}\n   * @public\n   */\n  appearing: _propTypes[\"default\"].bool,\n\n  /**\n   * Arranger to control the animation\n   *\n   * @type {Arranger}\n   * @public\n   */\n  arranger: _Arranger.shape,\n\n  /**\n   * An object containing properties to be passed to each child.\n   *\n   * @type {Object}\n   * @public\n   */\n  childProps: _propTypes[\"default\"].object,\n\n  /**\n   * Time, in milliseconds, to wait after a view has entered to inform it by passing the\n   * `enteringProp` as `false`.\n   *\n   * @type {Number}\n   * @default 0\n   * @public\n   */\n  enteringDelay: _propTypes[\"default\"].number,\n\n  /**\n   * Name of the property to pass to the wrapped view to indicate when it is entering the\n   * viewport. When `true`, the view has been created but has not transitioned into place.\n   * When `false`, the view has finished its transition.\n   *\n   * The notification can be delayed by setting `enteringDelay`. If not set, the view will not\n   * be notified of the change in transition.\n   *\n   * @type {String}\n   * @public\n   */\n  enteringProp: _propTypes[\"default\"].string,\n\n  /**\n   * Index of the currently 'active' view.\n   *\n   * @type {Number}\n   */\n  index: _propTypes[\"default\"].number,\n\n  /**\n   * When `true`, indicates if a view is currently leaving.\n   *\n   * @type {Boolean}\n   */\n  leaving: _propTypes[\"default\"].bool,\n\n  /**\n   * When `true`, indicates if the transition should be animated\n   *\n   * @type {Boolean}\n   * @default true\n   * @public\n   */\n  noAnimation: _propTypes[\"default\"].bool,\n\n  /**\n   * Index of the previously 'active' view.\n   *\n   * @type {Number}\n   */\n  previousIndex: _propTypes[\"default\"].number,\n\n  /**\n   * When `true`, indicates if the transition should be reversed. The effect depends on how the provided\n   * `arranger` handles reversal.\n   *\n   * @type {Boolean}\n   * @default false\n   */\n  reverseTransition: _propTypes[\"default\"].bool,\n\n  /**\n   * When `true`, indicates the current locale uses right-to-left reading order.\n   *\n   * The effect depends on how the provided `arranger` handles this option.\n   *\n   * @type {Boolean}\n   */\n  rtl: _propTypes[\"default\"].bool\n};\nView.defaultProps = {\n  appearing: false,\n  enteringDelay: 0,\n  index: 0,\n  reverseTransition: false\n};\n\nvar wrapWithView = function wrapWithView(config) {\n  return function (child) {\n    return /*#__PURE__*/_react[\"default\"].createElement(View, config, child);\n  };\n};\n\nexports.wrapWithView = wrapWithView;\nvar _default = View;\nexports[\"default\"] = _default;"]},"metadata":{},"sourceType":"module"}