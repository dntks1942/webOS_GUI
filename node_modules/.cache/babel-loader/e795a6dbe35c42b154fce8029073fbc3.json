{"ast":null,"code":"\"use strict\";\n\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\nexports.flickConfigPropType = exports.Flick = exports.defaultFlickConfig = exports[\"default\"] = void 0;\n\nvar _util = require(\"@enact/core/util\");\n\nvar _propTypes = _interopRequireDefault(require(\"prop-types\"));\n\nfunction _interopRequireDefault(obj) {\n  return obj && obj.__esModule ? obj : {\n    \"default\": obj\n  };\n}\n\nfunction _classCallCheck(instance, Constructor) {\n  if (!(instance instanceof Constructor)) {\n    throw new TypeError(\"Cannot call a class as a function\");\n  }\n}\n\nfunction _defineProperties(target, props) {\n  for (var i = 0; i < props.length; i++) {\n    var descriptor = props[i];\n    descriptor.enumerable = descriptor.enumerable || false;\n    descriptor.configurable = true;\n    if (\"value\" in descriptor) descriptor.writable = true;\n    Object.defineProperty(target, descriptor.key, descriptor);\n  }\n}\n\nfunction _createClass(Constructor, protoProps, staticProps) {\n  if (protoProps) _defineProperties(Constructor.prototype, protoProps);\n  if (staticProps) _defineProperties(Constructor, staticProps);\n  return Constructor;\n}\n\nvar Flick = /*#__PURE__*/function () {\n  function Flick() {\n    var _this = this;\n\n    _classCallCheck(this, Flick);\n\n    this.begin = function (_ref, _ref2, coords) {\n      var maxDuration = _ref.maxDuration,\n          maxMoves = _ref.maxMoves,\n          minVelocity = _ref.minVelocity;\n      var onFlick = _ref2.onFlick;\n      _this.minVelocity = minVelocity;\n      _this.maxMoves = maxMoves;\n\n      if (maxDuration !== null) {\n        _this.cancelJob.startAfter(maxDuration);\n      }\n\n      _this.tracking = !!onFlick;\n      _this.moves.length = 0;\n      _this.onFlick = onFlick;\n\n      _this.move(coords);\n    };\n\n    this.updateProps = function (_ref3) {\n      var onFlick = _ref3.onFlick; // Check `tracking` gesture is not in progress. Check if gesture exists before updating the references to the `onFlick`\n\n      if (!_this.tracking) return; // This will update the `onFlick` with the new value\n\n      _this.onFlick = onFlick;\n    };\n\n    this.move = function (_ref4) {\n      var x = _ref4.x,\n          y = _ref4.y;\n      if (!_this.tracking) return;\n\n      _this.moves.push({\n        x: x,\n        y: y,\n        t: window.performance.now()\n      }); // track specified # of points\n\n\n      if (_this.moves.length > _this.maxMoves) {\n        _this.moves.shift();\n      }\n    };\n\n    this.blur = function () {\n      _this.end();\n    };\n\n    this.cancel = function () {\n      _this.tracking = false;\n    };\n\n    this.cancelJob = new _util.Job(this.cancel);\n\n    this.end = function () {\n      if (!_this.tracking) return;\n\n      _this.cancelJob.stop();\n\n      var moves = _this.moves;\n\n      if (moves.length > 1) {\n        // note: important to use up time to reduce flick\n        // velocity based on time between move and up.\n        var last = moves[moves.length - 1];\n        var t = window.performance.now();\n        var x = 0,\n            y = 0; // take the greatest of flick between each tracked move and last move\n\n        for (var i = moves.length - 2, m; m = moves[i]; i--) {\n          // this flick (this move - last move) / (this time - last time)\n          var dt = t - m.t;\n          var vx = (last.x - m.x) / dt;\n          var vy = (last.y - m.y) / dt; // if either axis is a greater flick than previously recorded use this one\n\n          if (Math.abs(vx) > Math.abs(x) || Math.abs(vy) > Math.abs(y)) {\n            x = vx;\n            y = vy;\n          }\n        }\n\n        var v = Math.sqrt(x * x + y * y);\n\n        if (v > _this.minVelocity) {\n          var vertical = Math.abs(y) > Math.abs(x); // generate the flick using the start event so it has those coordinates\n          // this.sendFlick(ti.startEvent, x, y, v);\n\n          _this.onFlick({\n            type: 'onFlick',\n            direction: vertical ? 'vertical' : 'horizontal',\n            velocityX: x,\n            velocityY: y,\n            velocity: v\n          });\n        }\n      }\n\n      _this.tracking = false;\n    };\n\n    this.tracking = false;\n    this.moves = [];\n  }\n\n  _createClass(Flick, [{\n    key: \"isTracking\",\n    value: function isTracking() {\n      return this.tracking;\n    }\n  }]);\n\n  return Flick;\n}();\n\nexports.Flick = Flick;\nvar defaultFlickConfig = {\n  maxDuration: 250,\n  maxMoves: 5,\n  minVelocity: 0.1\n};\nexports.defaultFlickConfig = defaultFlickConfig;\n\nvar flickConfigPropType = _propTypes[\"default\"].shape({\n  maxDuration: _propTypes[\"default\"].number,\n  maxMoves: _propTypes[\"default\"].number,\n  maxVelocity: _propTypes[\"default\"].number\n});\n\nexports.flickConfigPropType = flickConfigPropType;\nvar _default = Flick;\nexports[\"default\"] = _default;","map":{"version":3,"sources":["/Users/sonjaeseong/workspace/webOS/CARROT/webOS_GUI/node_modules/@enact/ui/Touchable/Flick.js"],"names":["Object","defineProperty","exports","value","flickConfigPropType","Flick","defaultFlickConfig","_util","require","_propTypes","_interopRequireDefault","obj","__esModule","_classCallCheck","instance","Constructor","TypeError","_defineProperties","target","props","i","length","descriptor","enumerable","configurable","writable","key","_createClass","protoProps","staticProps","prototype","_this","begin","_ref","_ref2","coords","maxDuration","maxMoves","minVelocity","onFlick","cancelJob","startAfter","tracking","moves","move","updateProps","_ref3","_ref4","x","y","push","t","window","performance","now","shift","blur","end","cancel","Job","stop","last","m","dt","vx","vy","Math","abs","v","sqrt","vertical","type","direction","velocityX","velocityY","velocity","isTracking","shape","number","maxVelocity","_default"],"mappings":"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","sourcesContent":["\"use strict\";\n\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\nexports.flickConfigPropType = exports.Flick = exports.defaultFlickConfig = exports[\"default\"] = void 0;\n\nvar _util = require(\"@enact/core/util\");\n\nvar _propTypes = _interopRequireDefault(require(\"prop-types\"));\n\nfunction _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { \"default\": obj }; }\n\nfunction _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError(\"Cannot call a class as a function\"); } }\n\nfunction _defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if (\"value\" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } }\n\nfunction _createClass(Constructor, protoProps, staticProps) { if (protoProps) _defineProperties(Constructor.prototype, protoProps); if (staticProps) _defineProperties(Constructor, staticProps); return Constructor; }\n\nvar Flick = /*#__PURE__*/function () {\n  function Flick() {\n    var _this = this;\n\n    _classCallCheck(this, Flick);\n\n    this.begin = function (_ref, _ref2, coords) {\n      var maxDuration = _ref.maxDuration,\n          maxMoves = _ref.maxMoves,\n          minVelocity = _ref.minVelocity;\n      var onFlick = _ref2.onFlick;\n      _this.minVelocity = minVelocity;\n      _this.maxMoves = maxMoves;\n\n      if (maxDuration !== null) {\n        _this.cancelJob.startAfter(maxDuration);\n      }\n\n      _this.tracking = !!onFlick;\n      _this.moves.length = 0;\n      _this.onFlick = onFlick;\n\n      _this.move(coords);\n    };\n\n    this.updateProps = function (_ref3) {\n      var onFlick = _ref3.onFlick;\n      // Check `tracking` gesture is not in progress. Check if gesture exists before updating the references to the `onFlick`\n      if (!_this.tracking) return; // This will update the `onFlick` with the new value\n\n      _this.onFlick = onFlick;\n    };\n\n    this.move = function (_ref4) {\n      var x = _ref4.x,\n          y = _ref4.y;\n      if (!_this.tracking) return;\n\n      _this.moves.push({\n        x: x,\n        y: y,\n        t: window.performance.now()\n      }); // track specified # of points\n\n\n      if (_this.moves.length > _this.maxMoves) {\n        _this.moves.shift();\n      }\n    };\n\n    this.blur = function () {\n      _this.end();\n    };\n\n    this.cancel = function () {\n      _this.tracking = false;\n    };\n\n    this.cancelJob = new _util.Job(this.cancel);\n\n    this.end = function () {\n      if (!_this.tracking) return;\n\n      _this.cancelJob.stop();\n\n      var moves = _this.moves;\n\n      if (moves.length > 1) {\n        // note: important to use up time to reduce flick\n        // velocity based on time between move and up.\n        var last = moves[moves.length - 1];\n        var t = window.performance.now();\n        var x = 0,\n            y = 0; // take the greatest of flick between each tracked move and last move\n\n        for (var i = moves.length - 2, m; m = moves[i]; i--) {\n          // this flick (this move - last move) / (this time - last time)\n          var dt = t - m.t;\n          var vx = (last.x - m.x) / dt;\n          var vy = (last.y - m.y) / dt; // if either axis is a greater flick than previously recorded use this one\n\n          if (Math.abs(vx) > Math.abs(x) || Math.abs(vy) > Math.abs(y)) {\n            x = vx;\n            y = vy;\n          }\n        }\n\n        var v = Math.sqrt(x * x + y * y);\n\n        if (v > _this.minVelocity) {\n          var vertical = Math.abs(y) > Math.abs(x); // generate the flick using the start event so it has those coordinates\n          // this.sendFlick(ti.startEvent, x, y, v);\n\n          _this.onFlick({\n            type: 'onFlick',\n            direction: vertical ? 'vertical' : 'horizontal',\n            velocityX: x,\n            velocityY: y,\n            velocity: v\n          });\n        }\n      }\n\n      _this.tracking = false;\n    };\n\n    this.tracking = false;\n    this.moves = [];\n  }\n\n  _createClass(Flick, [{\n    key: \"isTracking\",\n    value: function isTracking() {\n      return this.tracking;\n    }\n  }]);\n\n  return Flick;\n}();\n\nexports.Flick = Flick;\nvar defaultFlickConfig = {\n  maxDuration: 250,\n  maxMoves: 5,\n  minVelocity: 0.1\n};\nexports.defaultFlickConfig = defaultFlickConfig;\n\nvar flickConfigPropType = _propTypes[\"default\"].shape({\n  maxDuration: _propTypes[\"default\"].number,\n  maxMoves: _propTypes[\"default\"].number,\n  maxVelocity: _propTypes[\"default\"].number\n});\n\nexports.flickConfigPropType = flickConfigPropType;\nvar _default = Flick;\nexports[\"default\"] = _default;"]},"metadata":{},"sourceType":"module"}