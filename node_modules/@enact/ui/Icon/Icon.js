"use strict";

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.Icon = exports["default"] = void 0;

var _kind = _interopRequireDefault(require("@enact/core/kind"));

var _util = require("@enact/core/util");

var _propTypes = _interopRequireDefault(require("prop-types"));

var _react = _interopRequireDefault(require("react"));

var _resolution = _interopRequireDefault(require("../resolution"));

var _IconModule = _interopRequireDefault(require("./Icon.module.css"));

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { "default": obj }; }

function _objectWithoutProperties(source, excluded) { if (source == null) return {}; var target = _objectWithoutPropertiesLoose(source, excluded); var key, i; if (Object.getOwnPropertySymbols) { var sourceSymbolKeys = Object.getOwnPropertySymbols(source); for (i = 0; i < sourceSymbolKeys.length; i++) { key = sourceSymbolKeys[i]; if (excluded.indexOf(key) >= 0) continue; if (!Object.prototype.propertyIsEnumerable.call(source, key)) continue; target[key] = source[key]; } } return target; }

function _objectWithoutPropertiesLoose(source, excluded) { if (source == null) return {}; var target = {}; var sourceKeys = Object.keys(source); var key, i; for (i = 0; i < sourceKeys.length; i++) { key = sourceKeys[i]; if (excluded.indexOf(key) >= 0) continue; target[key] = source[key]; } return target; }

/**
 * Merges consumer styles with the image `src` resolved through the resolution independence module.
 *
 * @function
 * @param	{Object}		style	Style object
 * @param	{String|Object}	src		URI to image or object of URIs
 *
 * @returns	{Object}				Original style object with backgroundImage updated
 * @private
 */
var mergeStyle = function mergeStyle(style, src) {
  var updated = Object.assign({}, style);

  var source = _resolution["default"].selectSrc(src);

  if (src && src !== 'none' && src !== 'inherit' && src !== 'initial') {
    source = "url(".concat(source, ")");
  }

  updated.backgroundImage = source;
  return updated;
};
/**
 * Tests if a string appears to be a URI/URL.
 *
 * @function
 * @param	{String}	c	Character to test
 *
 * @returns	{Boolean}		`true` if c looks like a URL
 * @private
 */


var isUri = function isUri(c) {
  return c.indexOf('/') > -1 || c.indexOf('.') > -1;
};
/**
 * A basic icon component structure without any behaviors applied to it.
 *
 * @class Icon
 * @memberof ui/Icon
 * @ui
 * @public
 */


var Icon = (0, _kind["default"])({
  name: 'ui:Icon',
  propTypes:
  /** @lends ui/Icon.Icon.prototype */
  {
    /**
     * The icon content.
     *
     * May be specified as either:
     *
     * * A string that represents an icon from the [iconList]{@link ui/Icon.Icon.iconList},
     * * An HTML entity string, Unicode reference or hex value (in the form '0x...'),
     * * A URL specifying path to an icon image, or
     * * An object representing a resolution independent resource (See {@link ui/resolution}).
     *
     * @type {String|Object}
     * @public
     */
    children: _propTypes["default"].oneOfType([_propTypes["default"].string, _propTypes["default"].object]),

    /**
     * Customizes the component by mapping the supplied collection of CSS class names to the
     * corresponding internal elements and states of this component.
     *
     * The following classes are supported:
     *
     * * `icon` - The root component class
     * * `dingbat` - Applied when the value of [`icon`]{@link ui/Icon.Icon.icon} is not
     *   found in [iconList]{@link ui/Icon.Icon.iconList}
     * * `large` - Applied when `size` prop is `'large'`
     * * `pressed` - Applied when `pressed` prop is `true`
     * * `small` - Applied when `size` prop is `'small'`
     *
     * @type {Object}
     * @public
     */
    css: _propTypes["default"].object,

    /**
     * Flip the icon horizontally, vertically or both.
     *
     * @type {('both'|'horizontal'|'vertical')}
     * @public
     */
    flip: _propTypes["default"].string,

    /**
     * The full list (hash) of supported icons.
     *
     * The keys of this hash are the unique names of each icon. The values are the unicode
     * characters to insert in the icon. These will typically map to glyphs in your icon-font.
     * The format of the keys can be character, glyph, or entity reference that correctly
     * renders in a React + JSX string.
     *
     * @type {Object}
     * @default {}
     * @public
     */
    iconList: _propTypes["default"].object,

    /**
     * Applies the `pressed` CSS class.
     *
     * @type {Boolean}
     * @default false
     * @public
     */
    pressed: _propTypes["default"].bool,

    /**
     * The size of the button.
     *
     * Applies the CSS class which can be customized by
     * [theming]{@link /docs/developer-guide/theming/}.
     *
     * @type {String}
     * @default 'small'
     * @public
     */
    size: _propTypes["default"].string
  },
  defaultProps: {
    iconList: {},
    pressed: false,
    size: 'small'
  },
  styles: {
    css: _IconModule["default"],
    className: 'icon',
    publicClassNames: true
  },
  computed: {
    className: function className(_ref) {
      var icon = _ref.children,
          flip = _ref.flip,
          iconList = _ref.iconList,
          pressed = _ref.pressed,
          size = _ref.size,
          styler = _ref.styler;
      return styler.append({
        // If the icon isn't in our known set, apply our custom font class
        dingbat: !(icon in iconList),
        pressed: pressed
      }, flip ? "flip".concat((0, _util.cap)(flip)) : null, size);
    },
    iconProps: function iconProps(_ref2) {
      var iconProp = _ref2.children,
          iconList = _ref2.iconList,
          style = _ref2.style;
      var icon = iconList[iconProp];

      if (!icon) {
        if (typeof iconProp == 'string') {
          if (iconProp.indexOf('&#x') === 0) {
            // Converts a hex reference in HTML entity form: &#x99999;
            icon = parseInt(iconProp.slice(3, -1), 16);
          } else if (iconProp.indexOf('&#') === 0) {
            // Convert an HTML entity: &#99999;
            icon = parseInt(iconProp.slice(2, -1));
          } else if (iconProp.indexOf("\\u") === 0) {
            // Convert a unicode reference: \u99999;
            icon = parseInt(iconProp.slice(2), 16);
          } else if (iconProp.indexOf('0x') === 0) {
            // Converts a hex reference in string form
            icon = String.fromCodePoint(iconProp);
          } else if (!isUri(iconProp)) {
            // A "simple" string is assumed to be an icon-name string
            icon = iconProp;
          } else {
            // for a path or URI, add it to style
            style = mergeStyle(style, iconProp);
          }
        } else if (typeof iconProp === 'object') {
          style = mergeStyle(style, iconProp);
        }
      }

      if (typeof icon == 'number') {
        // Converts a hex reference in number form
        icon = String.fromCodePoint(icon);
      }

      return {
        children: icon,
        style: style
      };
    }
  },
  render: function render(_ref3) {
    var iconProps = _ref3.iconProps,
        rest = _objectWithoutProperties(_ref3, ["iconProps"]);

    delete rest.iconList;
    delete rest.pressed;
    delete rest.size;
    return /*#__PURE__*/_react["default"].createElement("div", Object.assign({
      "aria-hidden": true
    }, rest, iconProps));
  }
});
exports.Icon = Icon;
var _default = Icon;
exports["default"] = _default;