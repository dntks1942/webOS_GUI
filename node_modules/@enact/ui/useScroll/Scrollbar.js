"use strict";

Object.defineProperty(exports, "__esModule", {
  value: true
});
Object.defineProperty(exports, "ScrollbarTrack", {
  enumerable: true,
  get: function get() {
    return _ScrollbarTrack["default"];
  }
});
exports.useScrollbar = exports.ScrollbarBase = exports.Scrollbar = exports["default"] = void 0;

var _classnames = _interopRequireDefault(require("classnames"));

var _util = require("@enact/core/util");

var _propTypes = _interopRequireDefault(require("prop-types"));

var _react = _interopRequireWildcard(require("react"));

var _reactDom = _interopRequireDefault(require("react-dom"));

var _resolution = _interopRequireDefault(require("../resolution"));

var _ScrollbarTrack = _interopRequireDefault(require("./ScrollbarTrack"));

var _ScrollbarModule = _interopRequireDefault(require("./Scrollbar.module.css"));

function _getRequireWildcardCache() { if (typeof WeakMap !== "function") return null; var cache = new WeakMap(); _getRequireWildcardCache = function _getRequireWildcardCache() { return cache; }; return cache; }

function _interopRequireWildcard(obj) { if (obj && obj.__esModule) { return obj; } if (obj === null || typeof obj !== "object" && typeof obj !== "function") { return { "default": obj }; } var cache = _getRequireWildcardCache(); if (cache && cache.has(obj)) { return cache.get(obj); } var newObj = {}; var hasPropertyDescriptor = Object.defineProperty && Object.getOwnPropertyDescriptor; for (var key in obj) { if (Object.prototype.hasOwnProperty.call(obj, key)) { var desc = hasPropertyDescriptor ? Object.getOwnPropertyDescriptor(obj, key) : null; if (desc && (desc.get || desc.set)) { Object.defineProperty(newObj, key, desc); } else { newObj[key] = obj[key]; } } } newObj["default"] = obj; if (cache) { cache.set(obj, newObj); } return newObj; }

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { "default": obj }; }

function _objectWithoutProperties(source, excluded) { if (source == null) return {}; var target = _objectWithoutPropertiesLoose(source, excluded); var key, i; if (Object.getOwnPropertySymbols) { var sourceSymbolKeys = Object.getOwnPropertySymbols(source); for (i = 0; i < sourceSymbolKeys.length; i++) { key = sourceSymbolKeys[i]; if (excluded.indexOf(key) >= 0) continue; if (!Object.prototype.propertyIsEnumerable.call(source, key)) continue; target[key] = source[key]; } } return target; }

function _objectWithoutPropertiesLoose(source, excluded) { if (source == null) return {}; var target = {}; var sourceKeys = Object.keys(source); var key, i; for (i = 0; i < sourceKeys.length; i++) { key = sourceKeys[i]; if (excluded.indexOf(key) >= 0) continue; target[key] = source[key]; } return target; }

var scrollbarTrackHidingDelay = 900; // 900ms + 100ms(fade out duration) = 1000ms.

var addClass = function addClass(element, className) {
  var node = _reactDom["default"].findDOMNode(element); // eslint-disable-line react/no-find-dom-node


  if (node) {
    node.classList.add(className);
  }
};

var removeClass = function removeClass(element, className) {
  var node = _reactDom["default"].findDOMNode(element); // eslint-disable-line react/no-find-dom-node


  if (node) {
    node.classList.remove(className);
  }
};
/*
 * Set CSS Variable value.
 *
 * @method
 * @param {Node} element - Node.
 * @param {String} variable - CSS Variable property.
 * @param {String} value - CSS Variable value.
 */


var setCSSVariable = function setCSSVariable(element, variable, value) {
  _reactDom["default"].findDOMNode(element).style.setProperty(variable, value); // eslint-disable-line react/no-find-dom-node

};
/**
 * A custom hook that passes scrollbar behavior information as its render prop.
 *
 * @class
 * @memberof ui/useScroll
 * @ui
 * @private
 */


var useScrollbar = function useScrollbar(props) {
  var className = props.className,
      clientSize = props.clientSize,
      corner = props.corner,
      css = props.css,
      minThumbSize = props.minThumbSize,
      scrollbarHandle = props.scrollbarHandle,
      vertical = props.vertical,
      rest = _objectWithoutProperties(props, ["className", "clientSize", "corner", "css", "minThumbSize", "scrollbarHandle", "vertical"]); // Refs


  var scrollbarContainerRef = (0, _react.useRef)();
  var scrollbarTrackRef = (0, _react.useRef)();
  var hideScrollbarTrackJob = (0, _react.useRef)(null);
  hideScrollbarTrackJob.current = hideScrollbarTrackJob.current || new _util.Job(hideScrollbarTrack, scrollbarTrackHidingDelay);

  function hideScrollbarTrack() {
    removeClass(scrollbarTrackRef.current, css.scrollbarTrackShown);
  }

  (0, _react.useEffect)(function () {
    return function () {
      hideScrollbarTrackJob.current.stop();
    };
  }, []);

  function getContainerRef() {
    return scrollbarContainerRef;
  }

  function showScrollbarTrack() {
    hideScrollbarTrackJob.current.stop();
    addClass(scrollbarTrackRef.current, css.scrollbarTrackShown);
  }

  function startHidingScrollbarTrack() {
    hideScrollbarTrackJob.current.start();
  }

  function update(bounds) {
    var primaryDimension = vertical ? 'clientHeight' : 'clientWidth',
        trackSize = clientSize ? clientSize[primaryDimension] : scrollbarContainerRef.current[primaryDimension],
        scrollViewSize = vertical ? bounds.clientHeight : bounds.clientWidth,
        scrollContentSize = vertical ? bounds.scrollHeight : bounds.scrollWidth,
        scrollOrigin = vertical ? bounds.scrollTop : bounds.scrollLeft,
        scrollbarThumbSizeRatioBase = scrollViewSize / scrollContentSize,
        scrollbarThumbProgressRatio = scrollOrigin / (scrollContentSize - scrollViewSize),
        scrollbarThumbSizeRatio = Math.max(_resolution["default"].scale(minThumbSize) / trackSize, Math.min(1, scrollbarThumbSizeRatioBase));
    setCSSVariable(scrollbarTrackRef.current, '--scrollbar-thumb-size-ratio', scrollbarThumbSizeRatio);
    setCSSVariable(scrollbarTrackRef.current, '--scrollbar-thumb-progress-ratio', scrollbarThumbProgressRatio);
  }

  if (scrollbarHandle) {
    scrollbarHandle.current = {
      getContainerRef: getContainerRef,
      showScrollbarTrack: showScrollbarTrack,
      startHidingScrollbarTrack: startHidingScrollbarTrack,
      update: update
    };
  }

  return {
    restProps: rest,
    scrollbarProps: {
      className: (0, _classnames["default"])(className, corner ? css.corner : null, css.scrollbar, vertical ? css.vertical : css.horizontal),
      ref: scrollbarContainerRef
    },
    scrollbarTrackProps: {
      ref: scrollbarTrackRef,
      vertical: vertical
    }
  };
};
/**
 * An unstyled scroll bar.
 *
 * @class Scrollbar
 * @memberof ui/useScroll
 * @ui
 * @private
 */


exports.useScrollbar = useScrollbar;
var Scrollbar = /*#__PURE__*/(0, _react.memo)(function (props) {
  var _useScrollbar = useScrollbar(props),
      restProps = _useScrollbar.restProps,
      scrollbarProps = _useScrollbar.scrollbarProps,
      scrollbarTrackProps = _useScrollbar.scrollbarTrackProps;

  return /*#__PURE__*/_react["default"].createElement("div", Object.assign({}, restProps, scrollbarProps), /*#__PURE__*/_react["default"].createElement(_ScrollbarTrack["default"], scrollbarTrackProps));
});
exports.ScrollbarBase = exports.Scrollbar = Scrollbar;
Scrollbar.displayName = 'ui:Scrollbar';
Scrollbar.propTypes =
/** @lends ui/useScroll.Scrollbar.prototype */
{
  /**
   * Client size of the container; valid values are an object that has `clientWidth` and `clientHeight`.
   *
   * @type {Object}
   * @property {Number}    clientHeight    The client height of the list.
   * @property {Number}    clientWidth    The client width of the list.
   * @public
   */
  clientSize: _propTypes["default"].shape({
    clientHeight: _propTypes["default"].number.isRequired,
    clientWidth: _propTypes["default"].number.isRequired
  }),

  /**
   * Adds a corner between the vertical and horizontal scrollbars.
   *
   * @type {Boolean}
   * @default false
   * @public
   */
  corner: _propTypes["default"].bool,

  /**
   * Customizes the component by mapping the supplied collection of CSS class names to the
   * corresponding internal elements and states of this component.
   *
   * The following classes are supported:
   *
   * * `scrollbar` - The scrollbar component class
   *
   * @type {Object}
   * @public
   */
  css: _propTypes["default"].object,

  /**
   * The minimum size of the thumb.
   *
   * This value will be scaled.
   *
   * @type {number}
   * @public
   */
  minThumbSize: _propTypes["default"].number,

  /**
   * If `true`, the scrollbar will be oriented vertically.
   *
   * @type {Boolean}
   * @default true
   * @public
   */
  vertical: _propTypes["default"].bool
};
Scrollbar.defaultProps = {
  corner: false,
  css: _ScrollbarModule["default"],
  minThumbSize: 18,
  vertical: true
};
var _default = Scrollbar;
exports["default"] = _default;