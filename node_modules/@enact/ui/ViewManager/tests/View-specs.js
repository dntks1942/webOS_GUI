"use strict";

var _react = _interopRequireDefault(require("react"));

var _enzyme = require("enzyme");

var _View = _interopRequireDefault(require("../View"));

var _testUtils = require("./test-utils");

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { "default": obj }; }

/* eslint-disable enact/prop-types */
describe('View', function () {
  test('should render its child when neither enteringProp or childProps is specified', function () {
    var subject = (0, _enzyme.mount)( /*#__PURE__*/_react["default"].createElement(_View["default"], {
      duration: 1000
    }, /*#__PURE__*/_react["default"].createElement("span", null)));
    var expected = 1;
    var actual = subject.find('span').length;
    expect(actual).toBe(expected);
  });
  test('should pass the value of entering to its child in enteringProp', function () {
    var subject = (0, _enzyme.mount)( /*#__PURE__*/_react["default"].createElement(_View["default"], {
      duration: 1000,
      enteringProp: "data-entering"
    }, /*#__PURE__*/_react["default"].createElement("span", null)));
    var expected = true;
    var actual = subject.find('span').prop('data-entering');
    expect(actual).toBe(expected);
  });
  test('should pass enteringProp as false for an appearing view', function () {
    // Views visible on mount are "appearing" and shouldn't perform "entering" logic like
    // deferring children rendering
    var subject = (0, _enzyme.mount)( /*#__PURE__*/_react["default"].createElement(_View["default"], {
      duration: 1000,
      enteringProp: "data-entering",
      appearing: true
    }, /*#__PURE__*/_react["default"].createElement("span", null)));
    var expected = false;
    var actual = subject.find('span').prop('data-entering');
    expect(actual).toBe(expected);
  });
  describe('imperative API without arranger', function () {
    test('should call callback immediately for "stay"', function () {
      var spy = jest.fn();
      var subject = (0, _enzyme.mount)( /*#__PURE__*/_react["default"].createElement(_View["default"], {
        duration: 16
      }, /*#__PURE__*/_react["default"].createElement("span", null)));
      subject.instance().componentWillStay(spy);
      var expected = true;
      var actual = spy.mock.calls.length === 1;
      expect(actual).toBe(expected);
    });
    test('should call callback immediately for "enter"', function () {
      var spy = jest.fn();
      var subject = (0, _enzyme.mount)( /*#__PURE__*/_react["default"].createElement(_View["default"], {
        duration: 16
      }, /*#__PURE__*/_react["default"].createElement("span", null)));
      subject.instance().componentWillEnter(spy);
      var expected = true;
      var actual = spy.mock.calls.length === 1;
      expect(actual).toBe(expected);
    });
    test('should call callback immediately for "leave"', function () {
      var spy = jest.fn();
      var subject = (0, _enzyme.mount)( /*#__PURE__*/_react["default"].createElement(_View["default"], {
        duration: 16
      }, /*#__PURE__*/_react["default"].createElement("span", null)));
      subject.instance().componentWillLeave(spy);
      var expected = true;
      var actual = spy.mock.calls.length === 1;
      expect(actual).toBe(expected);
    });
    test('should reset entering if a rendered panel re-enters', function () {
      var spy = jest.fn();
      var subject = (0, _enzyme.mount)( /*#__PURE__*/_react["default"].createElement(_View["default"], {
        duration: 16,
        enteringProp: "data-entering"
      }, /*#__PURE__*/_react["default"].createElement("span", null))); // This is a bit bad, but we need to clear entering without waiting
      // Could be updated to use `enteringDelay` and a small timeout

      subject.instance().componentDidAppear(spy);
      subject.update();
      var firstExpected = false;
      var firstActual = subject.find('span').prop('data-entering');
      expect(firstActual).toBe(firstExpected);
      subject.instance().componentWillEnter(spy);
      subject.update();
      var expected = true;
      var actual = subject.find('span').prop('data-entering');
      expect(actual).toBe(expected);
    });
  });
  describe('imperative API with arranger', function () {
    test('should call callback for "stay"', function (done) {
      var subject = (0, _enzyme.mount)( /*#__PURE__*/_react["default"].createElement(_View["default"], {
        duration: 16,
        arranger: _testUtils.MockArranger
      }, /*#__PURE__*/_react["default"].createElement("span", null)));
      var spy = jest.fn(function () {
        var expected = true;
        var actual = spy.mock.calls.length === 1;
        expect(actual).toBe(expected);
        done();
      });
      subject.instance().componentWillStay(spy);
    });
    test('should call callback for "enter"', function (done) {
      var subject = (0, _enzyme.mount)( /*#__PURE__*/_react["default"].createElement(_View["default"], {
        duration: 16,
        arranger: _testUtils.MockArranger
      }, /*#__PURE__*/_react["default"].createElement("span", null)));
      var spy = jest.fn(function () {
        var expected = true;
        var actual = spy.mock.calls.length === 1;
        expect(actual).toBe(expected);
        done();
      });
      subject.instance().componentWillEnter(spy);
    });
    test('should call callback for "leave"', function (done) {
      var subject = (0, _enzyme.mount)( /*#__PURE__*/_react["default"].createElement(_View["default"], {
        duration: 16,
        arranger: _testUtils.MockArranger
      }, /*#__PURE__*/_react["default"].createElement("span", null)));
      var spy = jest.fn(function () {
        var expected = true;
        var actual = spy.mock.calls.length === 1;
        expect(actual).toBe(expected);
        done();
      });
      subject.instance().componentWillLeave(spy);
    });
    test('should call callback immediately when {noAnimation}', function () {
      var spy = jest.fn();
      var subject = (0, _enzyme.mount)( /*#__PURE__*/_react["default"].createElement(_View["default"], {
        duration: 16,
        arranger: _testUtils.MockArranger,
        noAnimation: true
      }, /*#__PURE__*/_react["default"].createElement("span", null)));
      subject.instance().componentWillEnter(spy);
      var expected = true;
      var actual = spy.mock.calls.length === 1;
      expect(actual).toBe(expected);
    });
    test('should call callback immediately for "appear"', function () {
      var spy = jest.fn();
      var subject = (0, _enzyme.mount)( /*#__PURE__*/_react["default"].createElement(_View["default"], {
        duration: 16,
        arranger: _testUtils.MockArranger
      }, /*#__PURE__*/_react["default"].createElement("span", null)));
      subject.instance().componentWillAppear(spy);
      var expected = true;
      var actual = spy.mock.calls.length === 1;
      expect(actual).toBe(expected);
    });
  });
  describe('arranger API', function () {
    var arrangerStruct = {
      from: expect.any(Number),
      reverse: expect.any(Boolean),
      to: expect.any(Number),
      duration: expect.any(Number),
      fill: expect.any(String),
      node: expect.any(Object)
    };
    test('should pass the expected object to the arranger', function () {
      var arranger = {
        enter: jest.fn(function () {
          return {};
        })
      };
      var subject = (0, _enzyme.mount)( /*#__PURE__*/_react["default"].createElement(_View["default"], {
        duration: 1000,
        arranger: arranger
      }, /*#__PURE__*/_react["default"].createElement("span", null)));
      subject.instance().componentWillEnter();
      expect(arranger.enter).toBeCalledWith(arrangerStruct);
    });
  });
});