"use strict";

var _enzyme = require("enzyme");

var _react = _interopRequireDefault(require("react"));

var _spotlight = _interopRequireDefault(require("../../src/spotlight"));

var _pointer = require("../../src/pointer");

var _SpotlightContainerDecorator = _interopRequireDefault(require("../SpotlightContainerDecorator"));

var _ElementPrototype = _interopRequireDefault(require("./Element.prototype.closest"));

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { "default": obj }; }

function ownKeys(object, enumerableOnly) { var keys = Object.keys(object); if (Object.getOwnPropertySymbols) { var symbols = Object.getOwnPropertySymbols(object); if (enumerableOnly) symbols = symbols.filter(function (sym) { return Object.getOwnPropertyDescriptor(object, sym).enumerable; }); keys.push.apply(keys, symbols); } return keys; }

function _objectSpread(target) { for (var i = 1; i < arguments.length; i++) { var source = arguments[i] != null ? arguments[i] : {}; if (i % 2) { ownKeys(Object(source), true).forEach(function (key) { _defineProperty(target, key, source[key]); }); } else if (Object.getOwnPropertyDescriptors) { Object.defineProperties(target, Object.getOwnPropertyDescriptors(source)); } else { ownKeys(Object(source)).forEach(function (key) { Object.defineProperty(target, key, Object.getOwnPropertyDescriptor(source, key)); }); } } return target; }

function _defineProperty(obj, key, value) { if (key in obj) { Object.defineProperty(obj, key, { value: value, enumerable: true, configurable: true, writable: true }); } else { obj[key] = value; } return obj; }

describe('SpotlightContainerDecorator', function () {
  var hoverPosition = {
    clientX: 0,
    clientY: 1
  };
  var unhoverPosition = {
    clientX: 0,
    clientY: 0
  };

  var Div = function Div(props) {
    return /*#__PURE__*/_react["default"].createElement("div", props);
  };

  (0, _ElementPrototype["default"])(beforeAll, afterAll);
  beforeEach(function () {
    _spotlight["default"].setActiveContainer(null);

    (0, _pointer.updatePointerPosition)(0, 0);
  });
  test('should set itself as the active container on mouse enter', function () {
    var Component = (0, _SpotlightContainerDecorator["default"])(Div);
    var subject = (0, _enzyme.mount)( /*#__PURE__*/_react["default"].createElement(Component, {
      spotlightId: "test-container"
    }));
    subject.find(Div).prop('onMouseEnter')(hoverPosition);
    var expected = 'test-container';

    var actual = _spotlight["default"].getActiveContainer();

    expect(actual).toBe(expected);
  });
  test('should set active container to parent container on mouse leave', function () {
    var Component = (0, _SpotlightContainerDecorator["default"])(Div);
    var node = document.createElement('div');
    var subject = (0, _enzyme.mount)( /*#__PURE__*/_react["default"].createElement(Component, {
      spotlightId: "outer-container"
    }, /*#__PURE__*/_react["default"].createElement(Component, {
      spotlightId: "inner-container"
    })), {
      attachTo: node
    });
    var selector = 'div[data-spotlight-id="inner-container"]';
    var innerWrapper = subject.find(selector);
    var innerNode = node.querySelector(selector); // set inner-container as active

    innerWrapper.prop('onMouseEnter')(hoverPosition);
    (0, _pointer.updatePointerPosition)(0, 1); // leave inner-container

    innerWrapper.prop('onMouseLeave')(_objectSpread(_objectSpread({}, unhoverPosition), {}, {
      currentTarget: innerNode
    }));
    var expected = 'outer-container';

    var actual = _spotlight["default"].getActiveContainer();

    expect(actual).toBe(expected);
  });
  test('should not set active container on mouse leave if another container is active', function () {
    var Component = (0, _SpotlightContainerDecorator["default"])(Div);
    var node = document.createElement('div');
    var subject = (0, _enzyme.mount)( /*#__PURE__*/_react["default"].createElement(Component, {
      spotlightId: "outer-container"
    }, /*#__PURE__*/_react["default"].createElement(Component, {
      spotlightId: "inner-container"
    }), /*#__PURE__*/_react["default"].createElement(Component, {
      spotlightId: "self-only-container"
    })), {
      attachTo: node
    });
    var selector = 'div[data-spotlight-id="inner-container"]';
    var innerWrapper = subject.find(selector);
    var innerNode = node.querySelector(selector); // set inner-container as active

    innerWrapper.prop('onMouseEnter')(hoverPosition);
    (0, _pointer.updatePointerPosition)(0, 1); // set another container to be active

    _spotlight["default"].setActiveContainer('self-only-container'); // leave inner-container


    innerWrapper.prop('onMouseLeave')(_objectSpread(_objectSpread({}, unhoverPosition), {}, {
      currentTarget: innerNode
    }));
    var expected = 'self-only-container';

    var actual = _spotlight["default"].getActiveContainer();

    expect(actual).toBe(expected);
  });
  test('should forward onFocusCapture events', function () {
    var spy = jest.fn();
    var focus;
    var Component = (0, _SpotlightContainerDecorator["default"])(function (_ref) {
      var onFocusCapture = _ref.onFocusCapture;
      focus = onFocusCapture;
      return /*#__PURE__*/_react["default"].createElement("div", null);
    });
    (0, _enzyme.mount)( /*#__PURE__*/_react["default"].createElement(Component, {
      onFocusCapture: spy
    }));
    focus({});
    var expected = 1;
    var actual = spy.mock.calls.length;
    expect(actual).toBe(expected);
  });
  test('should suppress onFocusCapture events when spotlightDisabled', function () {
    var spy = jest.fn();
    var focus;
    var Component = (0, _SpotlightContainerDecorator["default"])(function (_ref2) {
      var onFocusCapture = _ref2.onFocusCapture;
      focus = onFocusCapture;
      return /*#__PURE__*/_react["default"].createElement("div", null);
    });
    (0, _enzyme.mount)( /*#__PURE__*/_react["default"].createElement(Component, {
      onFocusCapture: spy,
      spotlightDisabled: true
    })); // building out the api called on the event object + target

    focus({
      stopPropagation: function stopPropagation() {
        return true;
      },
      target: {
        blur: function blur() {
          return true;
        }
      }
    });
    var expected = 0;
    var actual = spy.mock.calls.length;
    expect(actual).toBe(expected);
  });
  test('should forward onBlurCapture events', function () {
    var spy = jest.fn();

    var _blur;

    var Component = (0, _SpotlightContainerDecorator["default"])(function (_ref3) {
      var onBlurCapture = _ref3.onBlurCapture;
      _blur = onBlurCapture;
      return /*#__PURE__*/_react["default"].createElement("div", null);
    });
    (0, _enzyme.mount)( /*#__PURE__*/_react["default"].createElement(Component, {
      onBlurCapture: spy,
      spotlightDisabled: true
    })); // building out the api called on the event object + target

    _blur({
      stopPropagation: function stopPropagation() {
        return true;
      },
      target: {
        blur: function blur() {
          return _blur({});
        }
      }
    });

    var expected = 1;
    var actual = spy.mock.calls.length;
    expect(actual).toBe(expected);
  });
  test('should suppress onBlurCapture events when focus was suppressed', function () {
    var spy = jest.fn();
    var focus;

    var _blur2;

    var Component = (0, _SpotlightContainerDecorator["default"])(function (_ref4) {
      var onBlurCapture = _ref4.onBlurCapture,
          onFocusCapture = _ref4.onFocusCapture;
      _blur2 = onBlurCapture;
      focus = onFocusCapture;
      return /*#__PURE__*/_react["default"].createElement("div", null);
    });
    (0, _enzyme.mount)( /*#__PURE__*/_react["default"].createElement(Component, {
      onBlurCapture: spy,
      spotlightDisabled: true
    })); // building out the api called on the event object + target

    focus({
      stopPropagation: function stopPropagation() {
        return true;
      },
      target: {
        // the focus handler calls blur() on the target so we're simulating that here by
        // wiring our onBlurCapture handler directly to the invocation. This isn't a
        // perfect modeling of the system but serves to validate the callback
        // suppression logic.
        blur: function blur() {
          return _blur2({});
        }
      }
    });
    var expected = 0;
    var actual = spy.mock.calls.length;
    expect(actual).toBe(expected);
  });
});